[{"path":"https://plger.github.io/scDblFinder/articles/computeDoubletDensity.html","id":"tldr","dir":"Articles","previous_headings":"","what":"tl;dr","title":"Scoring potential doublets from simulated densities","text":"demonstrate, ’ll use one mammary gland datasets scRNAseq package. subset random set 1000 cells speed. purposes demonstration, ’ll perform extremely expedited analysis. One usually take care quality control, create diagnostic plots, etc., don’t space . run computeDoubletDensity() obtain doublet score cell based density simulated doublets around . log get better dynamic range.","code":"library(scRNAseq) sce <- BachMammaryData(samples=\"G_1\")  set.seed(1001) sce <- sce[,sample(ncol(sce), 1000)] library(scuttle) sce <- logNormCounts(sce)  library(scran) dec <- modelGeneVar(sce) hvgs <- getTopHVGs(dec, n=1000)  library(scater) set.seed(1002) sce <- runPCA(sce, ncomponents=10, subset_row=hvgs) sce <- runTSNE(sce, dimred=\"PCA\") set.seed(1003) library(scDblFinder) scores <- computeDoubletDensity(sce, subset.row=hvgs) plotTSNE(sce, colour_by=I(log1p(scores)))"},{"path":"https://plger.github.io/scDblFinder/articles/computeDoubletDensity.html","id":"overview","dir":"Articles","previous_headings":"","what":"Algorithm overview","title":"Scoring potential doublets from simulated densities","text":"use fairly simple approach doubletCells involves creating simulated doublets original data set: Perform PCA log-normalized expression cells dataset. Randomly select two cells add count profiles together. Compute log-normalized profile project PC space. Repeat 2 obtain \\(N_s\\) simulated doublet cells. cell, compute local density simulated doublets, scaled density original cells. used doublet score.","code":""},{"path":[]},{"path":"https://plger.github.io/scDblFinder/articles/computeDoubletDensity.html","id":"normalization-size-factors","dir":"Articles","previous_headings":"Size factor handling","what":"Normalization size factors","title":"Scoring potential doublets from simulated densities","text":"allow specification two sets size factors different purposes. first set normalization set: division counts size factors yields expression values compared across cells. necessary compute log-normalized expression values PCA. size factors usually computed method assumes genes DE. default library size normalization though arbitrary set size factors can used. size factor doublet computed sum size factors individual cells, based additivity scaling biases.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/computeDoubletDensity.html","id":"rna-content-size-factors","dir":"Articles","previous_headings":"Size factor handling","what":"RNA content size factors","title":"Scoring potential doublets from simulated densities","text":"second set RNA content set: division counts size factors yields expression values proportional absolute abundance across cells. affects creation simulated doublets controlling scaling count profiles individual cells. size factors normally estimated spike-ins, absence default using unity cells. use unity values implies library size cell good proxy total RNA content. unlikely true: technical biases mean library size imprecise relative estimate content. Saturation effects composition biases also mean expected library size population accurate estimate content. imprecision spread simulated doublets inaccuracy result systematic shift location true doublets. Arguably, problems exist doublet estimation method without spike-information. can hope inaccuracies minor effects creation simulated cells. Indeed, first effect mitigate second extent ensuring simulated doublets occupy neighbourhood true doublets.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/computeDoubletDensity.html","id":"interactions-between-them","dir":"Articles","previous_headings":"Size factor handling","what":"Interactions between them","title":"Scoring potential doublets from simulated densities","text":"two sets size factors play different roles possible specify . use following algorithm accommodate non-unity values RNA content size factors: RNA content size factors used scale counts first. ensures RNA content desired effect step 2 Section @ref(overview). normalization size factors also divided content size factors. ensures normalization correct effect, see . rest algorithm proceeds RNA content size factors unity. Addition count profiles done without scaling, normalized expression values computed rescaled normalization size factors. understand correctness rescaled normalization size factors, consider non-DE gene abundance \\(\\lambda_g\\). expected count cell \\(\\lambda_g s_i\\) scaling bias \\(s_i\\) (.e., normalization size factor). rescaled count \\(\\lambda_g s_i c_i^{-1}\\) RNA content size factor \\(c_i\\). rescaled normalization size factor \\(s_i c_i^{-1}\\), normalization yields \\(\\lambda_g\\) desired. also holds doublets scaling biases size factors additive.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/computeDoubletDensity.html","id":"doublet-score-calculations","dir":"Articles","previous_headings":"","what":"Doublet score calculations","title":"Scoring potential doublets from simulated densities","text":"assume simulation accurately mimics doublet creation - amongst things, assume doublets equally likely form cell populations differences total RNA subpopulations captured negligible. assumptions hold, given region expression space, number doublets among real cells proportional number simulated doublets lying region. Thus, probability cell doublet proportional ratio number neighboring simulated doublets number neighboring real cells. mild additional challenge number simulated cells \\(N_s\\) can vary. Ideally, like expected output function regardless user’s choice \\(N_s\\), .e., chosen value affect precision/speed trade-. Many doublet-based methods take \\(k\\)-nearest neighbours approach compute densities; \\(N_s\\) large relative number real cells, \\(k\\) nearest neighbours simulated, \\(N_s\\) small, nearest neighbors original cells. Thus, use modified version \\(k\\)NN approach whereby identify distance cell \\(k\\)-th nearest neighbor. defines hypersphere around cell count number simulated cells. compute odds ratio number simulated cells hypersphere \\(N_s\\), divided ratio \\(k\\) total number cells dataset. score captures relative frequency simulated cells real cells robust changes \\(N_s\\).","code":""},{"path":"https://plger.github.io/scDblFinder/articles/computeDoubletDensity.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Scoring potential doublets from simulated densities","text":"","code":"sessionInfo() ## R version 4.4.0 (2024-04-24) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 22.04.4 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats4    stats     graphics  grDevices utils     datasets  methods   ## [8] base      ##  ## other attached packages: ##  [1] bluster_1.14.0              scDblFinder_1.19.0          ##  [3] scater_1.32.0               ggplot2_3.5.1               ##  [5] scran_1.32.0                scuttle_1.14.0              ##  [7] ensembldb_2.28.0            AnnotationFilter_1.28.0     ##  [9] GenomicFeatures_1.56.0      AnnotationDbi_1.66.0        ## [11] scRNAseq_2.18.0             SingleCellExperiment_1.26.0 ## [13] SummarizedExperiment_1.34.0 Biobase_2.64.0              ## [15] GenomicRanges_1.56.0        GenomeInfoDb_1.40.1         ## [17] IRanges_2.38.0              S4Vectors_0.42.0            ## [19] BiocGenerics_0.50.0         MatrixGenerics_1.16.0       ## [21] matrixStats_1.3.0           BiocStyle_2.32.0            ##  ## loaded via a namespace (and not attached): ##   [1] jsonlite_1.8.8            magrittr_2.0.3            ##   [3] ggbeeswarm_0.7.2          gypsum_1.0.1              ##   [5] farver_2.1.2              rmarkdown_2.27            ##   [7] fs_1.6.4                  BiocIO_1.14.0             ##   [9] zlibbioc_1.50.0           ragg_1.3.2                ##  [11] vctrs_0.6.5               memoise_2.0.1             ##  [13] Rsamtools_2.20.0          DelayedMatrixStats_1.26.0 ##  [15] RCurl_1.98-1.14           htmltools_0.5.8.1         ##  [17] S4Arrays_1.4.1            AnnotationHub_3.12.0      ##  [19] curl_5.2.1                BiocNeighbors_1.22.0      ##  [21] xgboost_1.7.7.1           Rhdf5lib_1.26.0           ##  [23] SparseArray_1.4.8         rhdf5_2.48.0              ##  [25] sass_0.4.9                alabaster.base_1.4.1      ##  [27] bslib_0.7.0               desc_1.4.3                ##  [29] alabaster.sce_1.4.0       httr2_1.0.1               ##  [31] cachem_1.1.0              GenomicAlignments_1.40.0  ##  [33] igraph_2.0.3              mime_0.12                 ##  [35] lifecycle_1.0.4           pkgconfig_2.0.3           ##  [37] rsvd_1.0.5                Matrix_1.7-0              ##  [39] R6_2.5.1                  fastmap_1.2.0             ##  [41] GenomeInfoDbData_1.2.12   digest_0.6.35             ##  [43] colorspace_2.1-0          dqrng_0.4.1               ##  [45] irlba_2.3.5.1             ExperimentHub_2.12.0      ##  [47] textshaping_0.4.0         RSQLite_2.3.7             ##  [49] beachmat_2.20.0           labeling_0.4.3            ##  [51] filelock_1.0.3            fansi_1.0.6               ##  [53] httr_1.4.7                abind_1.4-5               ##  [55] compiler_4.4.0            bit64_4.0.5               ##  [57] withr_3.0.0               BiocParallel_1.38.0       ##  [59] viridis_0.6.5             DBI_1.2.3                 ##  [61] highr_0.11                HDF5Array_1.32.0          ##  [63] alabaster.ranges_1.4.1    alabaster.schemas_1.4.0   ##  [65] MASS_7.3-60.2             rappdirs_0.3.3            ##  [67] DelayedArray_0.30.1       rjson_0.2.21              ##  [69] tools_4.4.0               vipor_0.4.7               ##  [71] beeswarm_0.4.0            glue_1.7.0                ##  [73] restfulr_0.0.15           rhdf5filters_1.16.0       ##  [75] grid_4.4.0                Rtsne_0.17                ##  [77] cluster_2.1.6             generics_0.1.3            ##  [79] gtable_0.3.5              data.table_1.15.4         ##  [81] metapod_1.12.0            BiocSingular_1.20.0       ##  [83] ScaledMatrix_1.12.0       utf8_1.2.4                ##  [85] XVector_0.44.0            ggrepel_0.9.5             ##  [87] BiocVersion_3.19.1        pillar_1.9.0              ##  [89] limma_3.60.2              dplyr_1.1.4               ##  [91] BiocFileCache_2.12.0      lattice_0.22-6            ##  [93] rtracklayer_1.64.0        bit_4.0.5                 ##  [95] tidyselect_1.2.1          locfit_1.5-9.9            ##  [97] Biostrings_2.72.1         knitr_1.47                ##  [99] gridExtra_2.3             bookdown_0.39             ## [101] ProtGenerics_1.36.0       edgeR_4.2.0               ## [103] xfun_0.44                 statmod_1.5.0             ## [105] UCSC.utils_1.0.0          lazyeval_0.2.2            ## [107] yaml_2.3.8                evaluate_0.24.0           ## [109] codetools_0.2-20          tibble_3.2.1              ## [111] alabaster.matrix_1.4.0    BiocManager_1.30.23       ## [113] cli_3.6.2                 systemfonts_1.1.0         ## [115] munsell_0.5.1             jquerylib_0.1.4           ## [117] Rcpp_1.0.12               dbplyr_2.5.0              ## [119] png_0.1-8                 XML_3.99-0.16.1           ## [121] parallel_4.4.0            pkgdown_2.0.9             ## [123] blob_1.2.4                sparseMatrixStats_1.16.0  ## [125] bitops_1.0-7              viridisLite_0.4.2         ## [127] alabaster.se_1.4.1        scales_1.3.0              ## [129] purrr_1.0.2               crayon_1.5.2              ## [131] rlang_1.1.4               KEGGREST_1.44.0"},{"path":"https://plger.github.io/scDblFinder/articles/findDoubletClusters.html","id":"tldr","dir":"Articles","previous_headings":"","what":"tl;dr","title":"Detecting clusters of doublet cells with DE analyses","text":"demonstrate, ’ll use one mammary gland datasets scRNAseq package. subset random set 500 cells speed. purposes demonstration, ’ll perform extremely expedited analysis. One usually take care quality control, create diagnostic plots, etc., don’t space .  run findDoubletClusters() test cluster null hypothesis consist doublets. null rejected cluster many DE genes lie outside expression limits defined “source” clusters. hand, num.de low, cluster’s expression profile consistent doublet hypothesis.","code":"library(scRNAseq) sce <- BachMammaryData(samples=\"G_2\")  set.seed(1000) sce <- sce[,sample(ncol(sce), 500)] library(scuttle) sce <- logNormCounts(sce)  library(scran) dec <- modelGeneVar(sce)  library(scater) set.seed(1000) sce <- runPCA(sce, ncomponents=10, subset_row=getTopHVGs(dec, n=1000))  library(bluster) clusters <- clusterRows(reducedDim(sce, \"PCA\"), NNGraphParam())  sce <- runTSNE(sce, dimred=\"PCA\") plotTSNE(sce, colour_by=I(clusters), text_by=I(clusters)) library(scDblFinder) tab <- findDoubletClusters(sce, clusters) tab ## DataFrame with 7 rows and 9 columns ##       source1     source2    num.de median.de               best     p.value ##   <character> <character> <integer> <integer>        <character>   <numeric> ## 6           2           1         0       122 ENSMUSG00000019256 1.00000e+00 ## 3           6           5         8        46 ENSMUSG00000002985 8.41352e-05 ## 7           5           1        11       393 ENSMUSG00000075705 2.04690e-10 ## 4           7           2        24        63 ENSMUSG00000022491 4.15645e-13 ## 1           7           6        86       715 ENSMUSG00000001349 8.49703e-08 ## 5           7           2       112      1007 ENSMUSG00000024610 2.38765e-11 ## 2           6           5       124       336 ENSMUSG00000023505 4.06936e-06 ##   lib.size1 lib.size2      prop ##   <numeric> <numeric> <numeric> ## 6  0.927081  0.443667     0.084 ## 3  2.026090  0.859424     0.242 ## 7  1.195040  1.249946     0.030 ## 4  0.630479  1.646729     0.150 ## 1  0.800035  2.253942     0.192 ## 5  0.836792  2.185591     0.032 ## 2  1.078655  0.457542     0.270"},{"path":"https://plger.github.io/scDblFinder/articles/findDoubletClusters.html","id":"mathematical-background","dir":"Articles","previous_headings":"","what":"Mathematical background","title":"Detecting clusters of doublet cells with DE analyses","text":"Consider cell population \\(\\) mean transcript count \\(\\lambda_{gi}\\) gene \\(g\\). Assume population exhibits unique scaling bias \\(s_i\\), representing efficiency library preparation population. observed read/UMI count gene \\(\\mu_{gi}=s_i\\lambda_{gi}\\). (simplicity, ignore gene-specific scaling biases, easily accommodated considering \\(\\lambda_{gi} \\equiv \\phi_g \\lambda_{gi}\\) bias \\(\\phi_g\\).) expected total count population \\(N_i = \\sum_g \\mu_{gi}\\). Now, let us consider doublet population \\(j\\) forms two parent populations \\(i_1\\) \\(i_2\\). observed read count \\(g\\) \\(j\\) \\(\\mu_{gj} = s_j (\\lambda_{gi_1} + \\lambda_{gi_2})\\). Note \\(s_j\\) need particular function \\(s_{i_1}\\) \\(s_{i_2}\\). Rather, relationship depends quickly reverse transcription amplification reagents saturated library preparation, difficult make assumptions around.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/findDoubletClusters.html","id":"normalization-by-library-size","dir":"Articles","previous_headings":"","what":"Normalization by library size","title":"Detecting clusters of doublet cells with DE analyses","text":"obtain log-normalized expression values cell based library size. Assume library size-normalized expression values \\(\\mu_{gi_1}N_{i_1}^{-1} < \\mu_{gi_2}N_{i_2}^{-1}\\), .e., proportion \\(g\\) increases \\(i_2\\) compared \\(i_1\\). contribution \\(s_i\\) cancels , yielding \\[ \\frac{\\lambda_{gi_1}}{\\sum_g \\lambda_{gi_1}} < \\frac{\\lambda_{gi_2}}{\\sum_g \\lambda_{gi_2}} \\;. \\] normalized expression value doublet cluster \\(j\\) subsequently \\[ \\frac{\\lambda_{gi_1} + \\lambda_{gi_2}}{\\sum_g (\\lambda_{gi_1} + \\lambda_{gi_2})} \\;, \\] fairly easy show \\[ \\frac{\\lambda_{gi_1}}{\\sum_g \\lambda_{gi_1}} < \\frac{\\lambda_{gi_1} + \\lambda_{gi_2}}{\\sum_g (\\lambda_{gi_1} + \\lambda_{gi_2})}  < \\frac{\\lambda_{gi_2}}{\\sum_g \\lambda_{gi_2}} \\;. \\] words, expected library size-normalized expression gene doublet cluster lies two parents. harder provide theoretical guarantees arbitrary size factors, use library sizes normalization instead. exception spike-size factors estimate \\(s_i\\) directly. allow us obtain estimates \\(\\lambda_{gi}\\) parent clusters \\(\\lambda_{gi_1} + \\lambda_{gi_2}\\) doublets. manner, precisely identify doublet clusters normalized expression value equal sum parents. Unfortunately, spike-ins generally available droplet-based data sets doublets problematic.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/findDoubletClusters.html","id":"testing-for-lack-of-intermediacy","dir":"Articles","previous_headings":"","what":"Testing for (lack of) intermediacy","title":"Detecting clusters of doublet cells with DE analyses","text":"want identify clusters may comprised doublets clusters. cluster \\(j'\\), test differential expression library size-normalized expression profiles every cluster \\('\\). pair clusters \\('_1\\) \\('_2\\), identify genes change \\(j'\\) \\('_1\\) \\('_2\\) direction. presence genes violates intermediacy expected doublet cluster provides evidence \\(j'\\) doublet \\('_1\\) \\('_2\\). Significant genes identified intersection-union test \\(p\\)-values pairwise comparisons \\(j'\\) \\('_1\\) \\('_2\\). (Specifically, \\(t\\)-tests used via findMarkers() function scran.) \\(p\\)-value gene set unity signs log-fold changes comparisons. Multiple correction testing applied using Benjamini-Hochberg method, number genes detected specified false discovery rate (usually 5%) counted. pair \\(('_1, '_2)\\) fewest detected genes considered putative parents \\(j'\\). theory, possible compute Simes’ combined \\(p\\)-value across genes reject doublet hypothesis \\(j'\\). provide rigorous approach ruling potential doublet/parent combinations. However, sensitive misspecification clusters – see .","code":""},{"path":"https://plger.github.io/scDblFinder/articles/findDoubletClusters.html","id":"calling-doublet-clusters","dir":"Articles","previous_headings":"","what":"Calling doublet clusters","title":"Detecting clusters of doublet cells with DE analyses","text":"Assuming clusters comprised doublets, identify clusters unusually low number detected genes violate intermediacy condition. achieved identifying small outliers log-transformed number detected genes, using median absolute deviation-based method function. (use log-transformation simply improve resolution low values.) Clusters likely doublets outliers metric. Doublet clusters also larger library sizes proposed parent clusters. consistent presence RNA doublet, though library size doublet cluster need sum parent clusters (due factors saturation composition effects). proportion cells assigned doublet cluster also “reasonable”; exactly means depends experimental setup doublet rate protocol use.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/findDoubletClusters.html","id":"discussion","dir":"Articles","previous_headings":"","what":"Discussion","title":"Detecting clusters of doublet cells with DE analyses","text":"biggest advantage approach lies interpretability. Given set existing clusters, can explicitly identify likely doublets. also gain insight onto parental origins putative doublet cluster, may interest. avoid assumptions doublet formation otherwise necessary simulation-based methods. particular, require knowledge exact relationship \\(s_j\\) \\(s_i\\), allowing us identify doublets even exact location doublet unknown (e.g., due differences RNA content parent clusters). downside , course, dependent supplied sensible clusters parental doublet cells separated. intermediacy requirement loose enough provide robustness misspecification, goes far. addition, strategy bias towards calling clusters cells doublets (parents doublets) DE detection power low. can somewhat offset comparing num.de median.de latter low clusters involved systematically low-powered comparisons, though difficult adjust exact effect differences power IUT.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/findDoubletClusters.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Detecting clusters of doublet cells with DE analyses","text":"","code":"sessionInfo() ## R version 4.4.0 (2024-04-24) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 22.04.4 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats4    stats     graphics  grDevices utils     datasets  methods   ## [8] base      ##  ## other attached packages: ##  [1] scDblFinder_1.19.0          bluster_1.14.0              ##  [3] scater_1.32.0               ggplot2_3.5.1               ##  [5] scran_1.32.0                scuttle_1.14.0              ##  [7] ensembldb_2.28.0            AnnotationFilter_1.28.0     ##  [9] GenomicFeatures_1.56.0      AnnotationDbi_1.66.0        ## [11] scRNAseq_2.18.0             SingleCellExperiment_1.26.0 ## [13] SummarizedExperiment_1.34.0 Biobase_2.64.0              ## [15] GenomicRanges_1.56.0        GenomeInfoDb_1.40.1         ## [17] IRanges_2.38.0              S4Vectors_0.42.0            ## [19] BiocGenerics_0.50.0         MatrixGenerics_1.16.0       ## [21] matrixStats_1.3.0           BiocStyle_2.32.0            ##  ## loaded via a namespace (and not attached): ##   [1] jsonlite_1.8.8            magrittr_2.0.3            ##   [3] ggbeeswarm_0.7.2          gypsum_1.0.1              ##   [5] farver_2.1.2              rmarkdown_2.27            ##   [7] fs_1.6.4                  BiocIO_1.14.0             ##   [9] zlibbioc_1.50.0           ragg_1.3.2                ##  [11] vctrs_0.6.5               memoise_2.0.1             ##  [13] Rsamtools_2.20.0          DelayedMatrixStats_1.26.0 ##  [15] RCurl_1.98-1.14           htmltools_0.5.8.1         ##  [17] S4Arrays_1.4.1            AnnotationHub_3.12.0      ##  [19] curl_5.2.1                BiocNeighbors_1.22.0      ##  [21] xgboost_1.7.7.1           Rhdf5lib_1.26.0           ##  [23] SparseArray_1.4.8         rhdf5_2.48.0              ##  [25] sass_0.4.9                alabaster.base_1.4.1      ##  [27] bslib_0.7.0               desc_1.4.3                ##  [29] alabaster.sce_1.4.0       httr2_1.0.1               ##  [31] cachem_1.1.0              GenomicAlignments_1.40.0  ##  [33] igraph_2.0.3              mime_0.12                 ##  [35] lifecycle_1.0.4           pkgconfig_2.0.3           ##  [37] rsvd_1.0.5                Matrix_1.7-0              ##  [39] R6_2.5.1                  fastmap_1.2.0             ##  [41] GenomeInfoDbData_1.2.12   digest_0.6.35             ##  [43] colorspace_2.1-0          dqrng_0.4.1               ##  [45] irlba_2.3.5.1             ExperimentHub_2.12.0      ##  [47] textshaping_0.4.0         RSQLite_2.3.7             ##  [49] beachmat_2.20.0           labeling_0.4.3            ##  [51] filelock_1.0.3            fansi_1.0.6               ##  [53] httr_1.4.7                abind_1.4-5               ##  [55] compiler_4.4.0            bit64_4.0.5               ##  [57] withr_3.0.0               BiocParallel_1.38.0       ##  [59] viridis_0.6.5             DBI_1.2.3                 ##  [61] highr_0.11                HDF5Array_1.32.0          ##  [63] alabaster.ranges_1.4.1    alabaster.schemas_1.4.0   ##  [65] MASS_7.3-60.2             rappdirs_0.3.3            ##  [67] DelayedArray_0.30.1       rjson_0.2.21              ##  [69] tools_4.4.0               vipor_0.4.7               ##  [71] beeswarm_0.4.0            glue_1.7.0                ##  [73] restfulr_0.0.15           rhdf5filters_1.16.0       ##  [75] grid_4.4.0                Rtsne_0.17                ##  [77] cluster_2.1.6             generics_0.1.3            ##  [79] gtable_0.3.5              data.table_1.15.4         ##  [81] metapod_1.12.0            BiocSingular_1.20.0       ##  [83] ScaledMatrix_1.12.0       utf8_1.2.4                ##  [85] XVector_0.44.0            ggrepel_0.9.5             ##  [87] BiocVersion_3.19.1        pillar_1.9.0              ##  [89] limma_3.60.2              dplyr_1.1.4               ##  [91] BiocFileCache_2.12.0      lattice_0.22-6            ##  [93] rtracklayer_1.64.0        bit_4.0.5                 ##  [95] tidyselect_1.2.1          locfit_1.5-9.9            ##  [97] Biostrings_2.72.1         knitr_1.47                ##  [99] gridExtra_2.3             bookdown_0.39             ## [101] ProtGenerics_1.36.0       edgeR_4.2.0               ## [103] xfun_0.44                 statmod_1.5.0             ## [105] UCSC.utils_1.0.0          lazyeval_0.2.2            ## [107] yaml_2.3.8                evaluate_0.24.0           ## [109] codetools_0.2-20          tibble_3.2.1              ## [111] alabaster.matrix_1.4.0    BiocManager_1.30.23       ## [113] cli_3.6.2                 systemfonts_1.1.0         ## [115] munsell_0.5.1             jquerylib_0.1.4           ## [117] Rcpp_1.0.12               dbplyr_2.5.0              ## [119] png_0.1-8                 XML_3.99-0.16.1           ## [121] parallel_4.4.0            pkgdown_2.0.9             ## [123] blob_1.2.4                sparseMatrixStats_1.16.0  ## [125] bitops_1.0-7              viridisLite_0.4.2         ## [127] alabaster.se_1.4.1        scales_1.3.0              ## [129] purrr_1.0.2               crayon_1.5.2              ## [131] rlang_1.1.4               KEGGREST_1.44.0"},{"path":"https://plger.github.io/scDblFinder/articles/introduction.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Introduction to the scDblFinder package","text":"scDblFinder package gathers various methods detection handling doublets/multiplets single-cell sequencing data (.e. multiple cells captured within droplet reaction volume). vignette provides brief overview different approaches (covered vignettes) single-cell RNA sequencing. doublet detection genomic data, see scATACseq vignette. general introduction topic doublets, refer OCSA book. methods require input either matrix counts SingleCellExperiment containing count data. exception findDoubletClusters, operates level clusters (consequently requires clustering information), methods try assign cell score indicating likelihood (broadly understood) doublet. approaches described complementary doublets identified via cell hashes SNPs multiplexed samples: hashing/genotypes can identify doublets formed cells type (homotypic doublets) two samples, often nearly undistinguishable real cells transcriptionally (hence generally unidentifiable present package), identify doublets made cells sample, even heterotypic (formed different cell types). Instead, methods presented primarily geared towards identification heterotypic doublets, purposes also critical ones.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/introduction.html","id":"computedoubletdensity","dir":"Articles","previous_headings":"Introduction","what":"computeDoubletDensity","title":"Introduction to the scDblFinder package","text":"computeDoubletDensity method (formerly scran::doubletCells) generates random artificial doublets real cells, tries identify cells whose neighborhood high local density articial doublets. See computeDoubletDensity information.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/introduction.html","id":"recoverdoublets","dir":"Articles","previous_headings":"Introduction","what":"recoverDoublets","title":"Introduction to the scDblFinder package","text":"recoverDoublets method meant used doublets already known, instance genotype-based calls cell hashing multiplexed experiments. function tries identify intra-sample doublets neighbors known inter-sample doublets. See recoverDoublets information.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/introduction.html","id":"scdblfinder","dir":"Articles","previous_headings":"Introduction","what":"scDblFinder","title":"Introduction to the scDblFinder package","text":"scDblFinder method combines known doublets (available) cluster-based artificial doublets identify doublets. approach builds improves variety earlier efforts, present accurate approach included package. See scDblFinder information.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/introduction.html","id":"directdblclassification","dir":"Articles","previous_headings":"Introduction","what":"directDblClassification","title":"Introduction to the scDblFinder package","text":"directDblClassification method identifies doublets training classifier directly gene expression. follows procedure scDblFinder doublet generation iterative training, skips k-nearest neighbor step directly uses matrix real cells artificial doublets. computationally intensive generally leads worse predictions scDblFinder, included chiefly comparative purposes. See ?directDblClassification information.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/introduction.html","id":"finddoubletclusters","dir":"Articles","previous_headings":"Introduction","what":"findDoubletClusters","title":"Introduction to the scDblFinder package","text":"findDoubletClusters method identifies clusters likely composed doublets estimating whether expression profile lies two clusters. See findDoubletClusters information.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/introduction.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Introduction to the scDblFinder package","text":"","code":"if (!requireNamespace(\"BiocManager\", quietly = TRUE))     install.packages(\"BiocManager\") BiocManager::install(\"scDblFinder\")  # or, to get that latest developments: BiocManager::install(\"plger/scDblFinder\")"},{"path":"https://plger.github.io/scDblFinder/articles/introduction.html","id":"which-method-to-choose","dir":"Articles","previous_headings":"","what":"Which method to choose?","title":"Introduction to the scDblFinder package","text":"benchmark main methods available package presented scDblFinder paper. different methods included values, overall scDblFinder method best performance (also superior methods included package), used default.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/introduction.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Introduction to the scDblFinder package","text":"","code":"sessionInfo() ## R version 4.4.0 (2024-04-24) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 22.04.4 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] BiocStyle_2.32.0 ##  ## loaded via a namespace (and not attached): ##  [1] vctrs_0.6.5         cli_3.6.2           knitr_1.47          ##  [4] rlang_1.1.4         xfun_0.44           purrr_1.0.2         ##  [7] textshaping_0.4.0   jsonlite_1.8.8      htmltools_0.5.8.1   ## [10] ragg_1.3.2          sass_0.4.9          rmarkdown_2.27      ## [13] evaluate_0.24.0     jquerylib_0.1.4     fastmap_1.2.0       ## [16] yaml_2.3.8          lifecycle_1.0.4     memoise_2.0.1       ## [19] bookdown_0.39       BiocManager_1.30.23 compiler_4.4.0      ## [22] fs_1.6.4            systemfonts_1.1.0   digest_0.6.35       ## [25] R6_2.5.1            magrittr_2.0.3      bslib_0.7.0         ## [28] tools_4.4.0         pkgdown_2.0.9       cachem_1.1.0        ## [31] desc_1.4.3"},{"path":"https://plger.github.io/scDblFinder/articles/recoverDoublets.html","id":"tldr","dir":"Articles","previous_headings":"","what":"tl;dr","title":"Recovering intra-sample doublets","text":"See relevant section OSCA book example recoverDoublets() function action real data. toy example also provided ?recoverDoublets.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/recoverDoublets.html","id":"mathematical-background","dir":"Articles","previous_headings":"","what":"Mathematical background","title":"Recovering intra-sample doublets","text":"Consider two cell states \\(C_1\\) \\(C_2\\) forming doublet population \\(D_{12}\\). focus relative frequency inter-sample intra-sample doublets \\(D_{12}\\). Given vector \\(\\vec p_X\\) containing proportion cells sample state \\(X\\), assuming doublets form randomly pairs samples, expected proportion intra-sample doublets \\(D_{12}\\) \\(\\vec p_{C_1} \\cdot \\vec p_{C_2}\\). Subtracting 1 gives us expected proportion inter-sample doublets \\(q_{D_{12}}\\). Similarly, expected proportion inter-sample doublets \\(C_1\\) just \\(q_{C_1} =1 - \\| \\vec p_{C_1} \\|_2^2\\). Now, let’s consider observed proportion events \\(r_X\\) state \\(X\\) known doublets. \\(r_{D_{12}} = q_{D_{12}}\\) events \\(D_{12}\\) beyond actual doublets. hand, expect \\(r_{C_1} \\ll q_{C_1}\\) due presence large majority non-doublet cells \\(C_1\\) (\\(C_2\\)). assume \\(q_{D_{12}} \\ge q_{C_1}\\) \\(q_{C_2}\\), observed proportion \\(r_{D_{12}}\\) larger \\(r_{C_1}\\) \\(r_{C_2}\\). (last assumption always true \\(\\ll\\) give us enough wiggle room robust violations.) reasoning motivates use proportion known doublet neighbors “doublet score” identify events likely doublets. recoverDoublets() computes proportion known doublet neighbors cell performing \\(k\\)-nearest neighbor search cells dataset. straightforward calculate proportion neighboring cells marked known doublets, representing estimate \\(r_X\\) cell.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/recoverDoublets.html","id":"obtaining-explicit-calls","dir":"Articles","previous_headings":"","what":"Obtaining explicit calls","title":"Recovering intra-sample doublets","text":"proportions informative, comes time need convert explicit doublet calls. achieved \\(\\vec S\\), vector proportion cells sample across entire dataset (.e., samples). assume cell states contributing doublet states proportion vectors equal \\(\\vec S\\), expected proportion doublets occur cells sample \\(\\| \\vec S\\|_2^2\\). solve \\[ \\frac{N_{intra}}{(N_{intra} + N_{inter}} = \\| \\vec S\\|_2^2 \\] \\(N_{intra}\\), \\(N_{inter}\\) number observed inter-sample doublets. top \\(N_{intra}\\) events highest scores (, obviously, already inter-sample doublets) marked putative intra-sample doublets.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/recoverDoublets.html","id":"discussion","dir":"Articles","previous_headings":"","what":"Discussion","title":"Recovering intra-sample doublets","text":"rate manner doublet formation (mostly) irrelevant condition number events \\(D_{12}\\). means make assumptions relative likelihood doublets forming pairs cell types, especially cell types different levels “stickiness” (worse, stick specifically certain cell types). convenience possible known doublet calls allow us focus inter- intra-sample ratio. problematic assumption required obtain \\(N_{intra}\\) \\(\\vec S\\). Obtaining better estimate require, least, knowledge two parent states doublet population. can determined simulation-based heuristics likely trouble worth. theoretical framework, can easily spot case method fails. \\(C_1\\) \\(C_2\\) unique given sample, events \\(D_{12}\\) intra-sample doublets. means events \\(D_{12}\\) ever detected inter-sample doublets, precludes detection intra-sample doublets recoverDoublets. computational remedy augment predictions simulation-based methods (e.g., scDblFinder()) experimental remedy ensure multiplexed samples include technical biological replicates.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/recoverDoublets.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Recovering intra-sample doublets","text":"","code":"sessionInfo() ## R version 4.4.0 (2024-04-24) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 22.04.4 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] BiocStyle_2.32.0 ##  ## loaded via a namespace (and not attached): ##  [1] vctrs_0.6.5         cli_3.6.2           knitr_1.47          ##  [4] rlang_1.1.4         xfun_0.44           purrr_1.0.2         ##  [7] textshaping_0.4.0   jsonlite_1.8.8      htmltools_0.5.8.1   ## [10] ragg_1.3.2          sass_0.4.9          rmarkdown_2.27      ## [13] evaluate_0.24.0     jquerylib_0.1.4     fastmap_1.2.0       ## [16] yaml_2.3.8          lifecycle_1.0.4     memoise_2.0.1       ## [19] bookdown_0.39       BiocManager_1.30.23 compiler_4.4.0      ## [22] fs_1.6.4            systemfonts_1.1.0   digest_0.6.35       ## [25] R6_2.5.1            magrittr_2.0.3      bslib_0.7.0         ## [28] tools_4.4.0         pkgdown_2.0.9       cachem_1.1.0        ## [31] desc_1.4.3"},{"path":"https://plger.github.io/scDblFinder/articles/scATAC.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Doublet identifiation in single-cell ATAC-seq","text":"Analyses single-cell RNAseq typically limited relatively small (e.g. one two thousands) set features informative; often genes higher expression (hence chances quantified). contrast, single-cell ATACseq (scATACseq) data considerably sparse, reads spread across hundreds thousands regions. context, selecting subset genes highly ineffective, therefore many methods developed single-cell RNAseq easily applicable, need adapted. Methods therefore developed specifically scATACseq data (Granja et al. 2021; Thibodeau et al. 2021). vignette presents different approaches doublet detection single-cell ATAC-seq implemented package: first adaptation scDblFinder, second reimplementation AMULET method Thibodeau et al. (2021). latter advantage capturing homotypic doublets, perform well datasets, especially requires cells high library size. therefore next present two ways combining two.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/scATAC.html","id":"applying-the-scdblfinder-method","dir":"Articles","previous_headings":"","what":"Applying the scDblFinder method","title":"Doublet identifiation in single-cell ATAC-seq","text":"default parameters, scDblFinder method performs poorly scATACseq data due increase spread reads across many features. Since working features (.e. tiles peaks) computationally expensive, alternative approach begin reducing size dataset, selection (scRNAseq), aggregating correlated features relatively small set. advantage using information, well making count data continuous. method yields comparable performance specialized single-cell ATACseq software (Germain et al., 2021). feature aggregation can triggered using aggregateFeatures=TRUE argument, aggregate peak tile counts number meta-features defined nfeatures. number meta-features low (recommend), meta-features can directly used calculated distances rather going SVD step (can triggered processing argument). example : encounter problems running aggregation-based approach large datasets, first make sure mbkmeans package installed.","code":"suppressPackageStartupMessages(library(scDblFinder)) # we use a dummy SingleCellExperiment as example: sce <- mockDoubletSCE(ngenes=300) # setting low number of artificial doublets (same as ncells) just for speedup: sce <- scDblFinder(sce, artificialDoublets=1, aggregateFeatures=TRUE, nfeatures=25, processing=\"normFeatures\") ## Aggregating features... ## Creating ~526 artificial doublets... ## Dimensional reduction ## Evaluating kNN... ## Training model... ## iter=0, 17 cells excluded from training. ## iter=1, 34 cells excluded from training. ## iter=2, 36 cells excluded from training. ## Threshold found:0.705 ## 18 (3.4%) doublets called"},{"path":"https://plger.github.io/scDblFinder/articles/scATAC.html","id":"using-the-amulet-method","dir":"Articles","previous_headings":"","what":"Using the Amulet method","title":"Doublet identifiation in single-cell ATAC-seq","text":"AMULET method Thibodeau et al. (2021) based assumption , diploid cell, given genomic region captured twice. Therefore, cells loci covered two fragments indicative droplet doublet. note, approach advantage capturing homotypic doublets, instead tend missed methods. Since available form mixture java python scripts, re-implemented method scDblFinder (see ?amulet), leading equal superior results original implementation (Germain et al. 2021). original implementation, recommend excluding mitochondrial sex chromosomes, well repetitive regions. can specified regionsToExclude argument (see underlying ?getFragmentOverlaps). can used follows: results data.frame statistics barcode, including p-value. contrast scDblFinder score, lower p-value indicative droplet likely doublet (original method). default, barcodes minimum number reads considered, possible specify droplets gather statistics using barcodes argument. package includes implementation works based peak/tile count matrices (see ?amuletFromCounts), much lower performance respect one based directly fragment files (see ?amulet), therefore discourage use. workhorse behind amulet function getFragmentOverlaps, also includes relevant arguments. fragment files Tabix-indexed, whole fragment file loaded memory processing; ensures relatively rapid computation, high memory requirements. Therefore, fragment file Tabix-indexed (instance done part ArchR pipeline), read processed per chromosome, little slower due overhead, keeps memory requirements rather low. behavior can disabled specifying fullInMemory=TRUE.","code":"# here we use a dummy fragment file for example: fragfile <- system.file(\"extdata\", \"example_fragments.tsv.gz\", package=\"scDblFinder\")  # we might also give a GRanges of repeat elements, so that these regions are excluded: suppressPackageStartupMessages(library(GenomicRanges)) repeats <- GRanges(\"chr6\", IRanges(1000,2000)) # it's better to combine these with mitochondrial and sex chromosomes otherChroms <- GRanges(c(\"M\",\"chrM\",\"MT\",\"X\",\"Y\",\"chrX\",\"chrY\"),IRanges(1L,width=10^8)) # here since I don't know what chromosome notation you'll be using I've just put them all, # although this will trigger a warning when combining them: toExclude <- suppressWarnings(c(repeats, otherChroms)) # we then launch the method res <- amulet(fragfile, regionsToExclude=toExclude) ## Fragment file is not tabix-indexed, requiring thewhole file to be imported in memory. ## 17:29:20 - Splitting and subsetting barcodes... ## 17:29:20 - Obtaining overlaps... res ##          nFrags uniqFrags nAbove2 total.nAbove2     p.value     q.value ## barcode1    878       878       1             1 0.475069053 0.791781755 ## barcode2   2401      2401       0             0 0.798103482 0.798103482 ## barcode3   2325      2325       1             1 0.475069053 0.791781755 ## barcode4   1882      1882       0             0 0.798103482 0.798103482 ## barcode5   1355      1355       6             6 0.001335761 0.006678806"},{"path":"https://plger.github.io/scDblFinder/articles/scATAC.html","id":"combining-mehtods","dir":"Articles","previous_headings":"","what":"Combining mehtods","title":"Doublet identifiation in single-cell ATAC-seq","text":"scDblFinder-based approach generally performs well, none two approach optimal across datasets tested. therefore investigated two strategies combining rationales approach. Amulet method tends perform best datasets homotypic doublets cells high library size (.e. median library size per cell 10-15k reads), scDblFinder-based approach works better heterotypic doublets. optimal solution found, recommend using multiple approaches inform decisions, particular using p-value combination method .","code":""},{"path":"https://plger.github.io/scDblFinder/articles/scATAC.html","id":"the-clamulet-method","dir":"Articles","previous_headings":"Combining mehtods","what":"The Clamulet method","title":"Doublet identifiation in single-cell ATAC-seq","text":"clamulet method (Classification-powered Amulet-like method) operates similarly scDblFinder method, generates artificial doublets operating fragment coverages. advantage number loci covered two reads can computed artificial doublets, enabling use feature (along kNN-based ones) classification scheme. however disadvantage rather slow memory hungry, appears outperformed simple p-value combination two methods (see ). therefore recommend usage. clamulet method uses aforementioned aggregation approach, usage includes number arguments scDblFinder amulet method (see particular ?getFragmentOverlaps): Since dummy fragment file small (5 barcodes), ’ll adjust arguments example run: score can interpreted scDblFinder. however note method proved inferior alternatives.","code":"# not run d <- clamulet(\"path/to/fragments.tsv.gz\") d <- clamulet(fragfile, k=2, nfeatures=3) ## 17:29:21 - Reading full fragments... ## 17:29:21 - Splitting and subsetting barcodes... ## 17:29:21 - Computing coverages ## 17:29:21 - Obtaining windows ## 17:29:21 - Obtaining window counts ## 17:29:22 - Aggregating features ## Warning in (function (A, nv = 5, nu = nv, maxit = 1000, work = nv + 7, reorth = ## TRUE, : You're computing too large a percentage of total singular values, use a ## standard svd instead. ## 17:29:22 - Computing features for artificial doublets ## 17:29:22 - Counting overlaps for real cells ## 17:29:22 - Counting overlaps for artificial doublets ## 17:29:22 - Scoring network ## 17:29:22 - Iterative training ## iter=0, 0 cells excluded from training. ## iter=1, 0 cells excluded from training. ## 17:29:22 Done! d ##          total nAbove2 total.nAbove2  weighted ratio.k2 include.in.training ## barcode1    20       1             1 0.5843011      0.5                TRUE ## barcode2    14       0             0       NaN      0.5                TRUE ## barcode3    11       1             1 1.0000000      1.0                TRUE ## barcode4    12       0             0       NaN      0.5                TRUE ## barcode5    18       6             6 0.4368783      0.5                TRUE ##              score ## barcode1 0.4174298 ## barcode2 0.4174298 ## barcode3 0.4174298 ## barcode4 0.4174298 ## barcode5 0.4174298"},{"path":"https://plger.github.io/scDblFinder/articles/scATAC.html","id":"simple-p-value-combination","dir":"Articles","previous_headings":"Combining mehtods","what":"Simple p-value combination","title":"Doublet identifiation in single-cell ATAC-seq","text":"amulet scDblFinder scores can simply combined treating p-values aggregating (using Fisher’s method aggregation package, see also metap package): found perform better averaging scores ranks, best method datasets tested, robust performance overall (see Germain et al., 2021).","code":"res$scDblFinder.p <- 1-colData(sce)[row.names(res), \"scDblFinder.score\"] res$combined <- apply(res[,c(\"scDblFinder.p\", \"p.value\")], 1, FUN=function(x){   x[x<0.001] <- 0.001 # prevent too much skew from very small or 0 p-values   suppressWarnings(aggregation::fisher(x)) })"},{"path":"https://plger.github.io/scDblFinder/articles/scATAC.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Doublet identifiation in single-cell ATAC-seq","text":"Jeffrey M. Granja et al., “ArchR Scalable Software Package Integrative Single-Cell Chromatin Accessibility Analysis,” Nature Genetics, February 25, 2021, 1–9, https://doi.org/10.1038/s41588-021-00790-6 Asa Thibodeau et al., “AMULET: Novel Read Count-Based Method Effective Multiplet Detection Single Nucleus ATAC-Seq Data,” Genome Biology 22, . 1 (December 2021): 252, https://doi.org/10.1186/s13059-021-02469-x Pierre-Luc Germain et al., “Doublet Identification Single-Cell Sequencing Data Using ScDblFinder” (F1000Research, September 28, 2021), https://doi.org/10.12688/f1000research.73600.1","code":""},{"path":"https://plger.github.io/scDblFinder/articles/scATAC.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Doublet identifiation in single-cell ATAC-seq","text":"","code":"sessionInfo() ## R version 4.4.0 (2024-04-24) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 22.04.4 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats4    stats     graphics  grDevices utils     datasets  methods   ## [8] base      ##  ## other attached packages: ##  [1] scDblFinder_1.19.0          SingleCellExperiment_1.26.0 ##  [3] SummarizedExperiment_1.34.0 Biobase_2.64.0              ##  [5] GenomicRanges_1.56.0        GenomeInfoDb_1.40.1         ##  [7] IRanges_2.38.0              S4Vectors_0.42.0            ##  [9] BiocGenerics_0.50.0         MatrixGenerics_1.16.0       ## [11] matrixStats_1.3.0           BiocStyle_2.32.0            ##  ## loaded via a namespace (and not attached): ##   [1] bitops_1.0-7              gridExtra_2.3             ##   [3] rlang_1.1.4               magrittr_2.0.3            ##   [5] scater_1.32.0             compiler_4.4.0            ##   [7] DelayedMatrixStats_1.26.0 systemfonts_1.1.0         ##   [9] vctrs_0.6.5               pkgconfig_2.0.3           ##  [11] crayon_1.5.2              fastmap_1.2.0             ##  [13] XVector_0.44.0            scuttle_1.14.0            ##  [15] utf8_1.2.4                Rsamtools_2.20.0          ##  [17] rmarkdown_2.27            UCSC.utils_1.0.0          ##  [19] ggbeeswarm_0.7.2          ragg_1.3.2                ##  [21] purrr_1.0.2               xfun_0.44                 ##  [23] bluster_1.14.0            zlibbioc_1.50.0           ##  [25] cachem_1.1.0              beachmat_2.20.0           ##  [27] jsonlite_1.8.8            DelayedArray_0.30.1       ##  [29] BiocParallel_1.38.0       irlba_2.3.5.1             ##  [31] parallel_4.4.0            cluster_2.1.6             ##  [33] R6_2.5.1                  bslib_0.7.0               ##  [35] limma_3.60.2              rtracklayer_1.64.0        ##  [37] xgboost_1.7.7.1           jquerylib_0.1.4           ##  [39] Rcpp_1.0.12               bookdown_0.39             ##  [41] knitr_1.47                Matrix_1.7-0              ##  [43] igraph_2.0.3              tidyselect_1.2.1          ##  [45] abind_1.4-5               yaml_2.3.8                ##  [47] viridis_0.6.5             codetools_0.2-20          ##  [49] curl_5.2.1                lattice_0.22-6            ##  [51] tibble_3.2.1              evaluate_0.24.0           ##  [53] desc_1.4.3                Biostrings_2.72.1         ##  [55] pillar_1.9.0              BiocManager_1.30.23       ##  [57] generics_0.1.3            RCurl_1.98-1.14           ##  [59] ggplot2_3.5.1             sparseMatrixStats_1.16.0  ##  [61] munsell_0.5.1             scales_1.3.0              ##  [63] glue_1.7.0                metapod_1.12.0            ##  [65] tools_4.4.0               BiocIO_1.14.0             ##  [67] data.table_1.15.4         BiocNeighbors_1.22.0      ##  [69] ScaledMatrix_1.12.0       locfit_1.5-9.9            ##  [71] GenomicAlignments_1.40.0  fs_1.6.4                  ##  [73] scran_1.32.0              XML_3.99-0.16.1           ##  [75] grid_4.4.0                edgeR_4.2.0               ##  [77] colorspace_2.1-0          GenomeInfoDbData_1.2.12   ##  [79] beeswarm_0.4.0            BiocSingular_1.20.0       ##  [81] restfulr_0.0.15           vipor_0.4.7               ##  [83] cli_3.6.2                 rsvd_1.0.5                ##  [85] textshaping_0.4.0         fansi_1.0.6               ##  [87] S4Arrays_1.4.1            viridisLite_0.4.2         ##  [89] dplyr_1.1.4               gtable_0.3.5              ##  [91] sass_0.4.9                digest_0.6.35             ##  [93] SparseArray_1.4.8         ggrepel_0.9.5             ##  [95] dqrng_0.4.1               rjson_0.2.21              ##  [97] memoise_2.0.1             htmltools_0.5.8.1         ##  [99] pkgdown_2.0.9             lifecycle_1.0.4           ## [101] httr_1.4.7                statmod_1.5.0             ## [103] MASS_7.3-60.2"},{"path":"https://plger.github.io/scDblFinder/articles/scDblFinder.html","id":"scdblfinder","dir":"Articles","previous_headings":"","what":"scDblFinder","title":"scDblFinder","text":"scDblFinder method combines strengths various doublet detection approaches, training iterative classifier neighborhood real cells artificial doublets. scDblFinder() two main modes operation: cluster-based . perform quite well (see Germain et al., 2021). general, recommend cluster-based approach datasets clear cluster structure, random approach complex datasets.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/scDblFinder.html","id":"installation","dir":"Articles","previous_headings":"scDblFinder","what":"Installation","title":"scDblFinder","text":"","code":"if (!requireNamespace(\"BiocManager\", quietly = TRUE))     install.packages(\"BiocManager\") BiocManager::install(\"scDblFinder\")  # or, to get that latest developments: BiocManager::install(\"plger/scDblFinder\")"},{"path":"https://plger.github.io/scDblFinder/articles/scDblFinder.html","id":"usage","dir":"Articles","previous_headings":"scDblFinder","what":"Usage","title":"scDblFinder","text":"input scDblFinder object sce class SingleCellExperiment (empty drops already removed) containing least counts (assay ‘counts’). Alternatively, simple count matrix can also provided. Given SCE object, scDblFinder (using random approach) can launched follows : 10x data, usually safe leave dbr empty, automatically estimated. scDblFinder add number columns colData sce prefixed ‘scDblFinder’, important : sce$scDblFinder.score : final doublet score sce$scDblFinder.class : classification (doublet singlet) can compare calls truth toy example: use cluster-based approach, one simply needs additionally provide clusters argument: clusters argument can either vector cluster labels column sce, colData column sce containing labels, TRUE. clusters=TRUE, fast clustering approach (see ?fastcluster) employed. normalized expression (assay ‘logcounts’) /PCA (reducedDim ‘PCA’) already present object, used clustering step.","code":"set.seed(123) suppressPackageStartupMessages(library(scDblFinder)) # we create a dummy dataset; since it's small we set a higher doublet rate sce <- mockDoubletSCE(dbl.rate=0.1, ngenes=300 ) # we run scDblFinder (providing the unusually high doublet rate) sce <- scDblFinder(sce, dbr=0.1) ## Creating ~1500 artificial doublets... ## Dimensional reduction ## Evaluating kNN... ## Training model... ## iter=0, 38 cells excluded from training. ## iter=1, 25 cells excluded from training. ## iter=2, 25 cells excluded from training. ## Threshold found:0.326 ## 28 (5.3%) doublets called table(truth=sce$type, call=sce$scDblFinder.class) ##          call ## truth     singlet doublet ##   singlet     496       4 ##   doublet       0      24 sce <- scDblFinder(sce, clusters=\"cluster\") ## 2 clusters ## Creating ~1500 artificial doublets... ## Dimensional reduction ## Evaluating kNN... ## Training model... ## iter=0, 24 cells excluded from training. ## iter=1, 24 cells excluded from training. ## iter=2, 19 cells excluded from training. ## Threshold found:0.764 ## 19 (3.6%) doublets called table(truth=sce$type, call=sce$scDblFinder.class) ##          call ## truth     singlet doublet ##   singlet     500       0 ##   doublet       5      19"},{"path":"https://plger.github.io/scDblFinder/articles/scDblFinder.html","id":"multiple-samples","dir":"Articles","previous_headings":"scDblFinder > Usage","what":"Multiple samples","title":"scDblFinder","text":"multiple samples (understood different cell captures), preferable look doublets separately sample (multiplexed samples cell hashes, means batch). can simply providing vector sample ids samples parameter scDblFinder , stored column colData, name column. case, might also consider multithreading using BPPARAM parameter (assuming ’ve got enough RAM!). example: Note running multiple samples using cluster-based approach (see ), clustering performed sample-wise. typically issue doublet identification, means cluster labels (putative origins doublets) won’t match samples. interested , preferable first cluster (example using sce$cluster <- fastcluster(sce)) provide clusters scDblFinder, ensure concordant labels across samples. note, large differences number cells samples scores directly comparable. working improving , meantime preferable stratify similar samples threshold sets separately.","code":"library(BiocParallel) sce <- scDblFinder(sce, samples=\"sample_id\", BPPARAM=MulticoreParam(3)) table(sce$scDblFinder.class)"},{"path":"https://plger.github.io/scDblFinder/articles/scDblFinder.html","id":"description-of-the-method","dir":"Articles","previous_headings":"scDblFinder","what":"Description of the method","title":"scDblFinder","text":"Wrapped scDblFinder function following steps:","code":""},{"path":"https://plger.github.io/scDblFinder/articles/scDblFinder.html","id":"splitting-captures","dir":"Articles","previous_headings":"scDblFinder > Description of the method","what":"Splitting captures","title":"scDblFinder","text":"Doublets can arise within given sample capture, reason better sought independently sample, also speeds analysis. samples argument given, scDblFinder use split cells samples/captures, process parallel BPPARAM argument given. Depending multiSampleMode argument, classifier can trained globally, thresholds optimized per-sample basis; however see improvement , therefore default sample treated separately maximize robustness technical differences. samples multiplexed, .e. different samples mixed different batches, batches provide argument.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/scDblFinder.html","id":"reducing-and-clustering-the-data","dir":"Articles","previous_headings":"scDblFinder > Description of the method","what":"Reducing and clustering the data","title":"scDblFinder","text":"analysis can considerably sped , little cost accuracy, reducing dataset top expressed genes (controlled nfeatures argument). , depending clusters argument, eventual PCA clustering (using internal fastcluster function) performed. rationale cluster-based approach homotypic doublets nearly impossible distinguish basis transcriptome, therefore creating kind doublets waste computational resources can moreover mislead classifier flagging singlets. alternative approach, however, generate doublets randomly (setting clusters FALSE NULL), use iterative approach (see ) exclude also unidentifiable artificial doublets training.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/scDblFinder.html","id":"generating-artificial-doublets","dir":"Articles","previous_headings":"scDblFinder > Description of the method","what":"Generating artificial doublets","title":"scDblFinder","text":"Depending clusters propRandom arguments, artificial doublets generated combining random cells /pairs non-identical clusters (can performed manually using getArtificialDoublets function). proportion doublets simply use sum counts composing cells, rest undergo library size adjustment poisson resampling.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/scDblFinder.html","id":"examining-the-k-nearest-neighbors-knn-of-each-cell","dir":"Articles","previous_headings":"scDblFinder > Description of the method","what":"Examining the k-nearest neighbors (kNN) of each cell","title":"scDblFinder","text":"new PCA performed combination real artificial cells, kNN network generated. Using kNN, number parameters gathered cell, proportion doublets (.e. artificial doublets known doublets provided knownDoublets argument, given) among KNN, ratio distances nearest doublet nearest non-doublet, etc. Several features reported output ‘scDblFinder.’ prefix, e.g.: distanceToNearest : distance nearest cell (real artificial) ratio : proportion KNN doublets. (one value k given, various ratios used classification reported) weighted : proportion KNN doublets, weighted distance (useful isolated cells)","code":""},{"path":"https://plger.github.io/scDblFinder/articles/scDblFinder.html","id":"training-a-classifier","dir":"Articles","previous_headings":"scDblFinder > Description of the method","what":"Training a classifier","title":"scDblFinder","text":"Unless score argument set ‘weighted’ ‘ratio’ (case aforementioned ratio directly used doublet score), scDblFinder uses gradient boosted trees trained kNN-derived properties along additional features (e.g. library size, number non-zero features, estimate difficultly detecting artificial doublets cell’s neighborhood, variant cxds score scds, etc.) distinguish doublets (either artificial given) cells, assigns score basis. One problem using classifier task real cells (actual doublets) mislabeled singlet, speak. scDblFinder therefore iteratively retrains classifier, time excluding training (real) cells called doublets previous step (well unidentifiable artificial doublets). number steps controlled iter parameter (experience, 2 3 optimal). score available output, scDblFinder.score colData column, can interpreted probability. data multi-sample, single model trained samples.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/scDblFinder.html","id":"thresholding","dir":"Articles","previous_headings":"scDblFinder > Description of the method","what":"Thresholding","title":"scDblFinder","text":"Rather thresholding arbitrary cutoff score, scDblFinder uses expected number doublets combination misclassification rate establish threshold. Unless manually given dbr argument, expected doublet rate first estimated using empirical rule thumb applicable 10X data, namely roughly 1% per 1000 cells captured (5000 cells, (0.01*5)*5000 = 250 doublets, cells capture higher chance creating doublet). samples specified, dbr automatically calculated, thresholding performed separately across samples. Thresholding tries simultaneously minimize: 1) classification error (terms proportion known doublets threshold) 2) deviation expected number doublets among real cells (ratio total number expected doublets within range determined dbr.sd, adjusted homotypic doublets). means , idea doublet rate, setting dbr.sd=1 make threshold depend entirely misclassification rate.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/scDblFinder.html","id":"doublet-origins-and-enrichments","dir":"Articles","previous_headings":"scDblFinder > Description of the method","what":"Doublet origins and enrichments","title":"scDblFinder","text":"artificial doublets generated clusters, sometimes possible call likely origin (terms combination clusters) given putative real doublet. observed least one two composing cell typically recognized, seldom correctly recognized, owing sometimes small relative contribution one two original cells. information provided scDblFinder.mostLikelyOrigin column output (scDblFinder.originAmbiguous column indicates whether origin ambiguous rather clear). , turn, allows us identify enrichment expectation specific kinds doublets. statistics combination clusters saved metadata(sce)$scDblFinder.stats, plotDoubletMap function can used visualize enrichments. addition, two frameworks offered testing significance enrichments: clusterStickiness function tests whether cluster forms doublet expected given abundance, default using single quasi-binomial model fitted across doublet types. doubletPairwiseEnrichment function separately tests whether specific doublet type (.e. combination clusters) abundant expected, default using poisson model.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/scDblFinder.html","id":"some-important-parameters","dir":"Articles","previous_headings":"scDblFinder","what":"Some important parameters","title":"scDblFinder","text":"scDblFinder fair number parameters governing preprocessing, generation doublets, classification, etc. (see ?scDblFinder). describe just important ones.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/scDblFinder.html","id":"expected-proportion-of-doublets","dir":"Articles","previous_headings":"scDblFinder > Some important parameters","what":"Expected proportion of doublets","title":"scDblFinder","text":"expected proportion doublets impact density artificial doublets neighborhood, impacts classifier’s score , especially, cutoff placed. specified dbr parameter dbr.sd parameter (latter specifies +/- range around dbr within deviation dbr considered null). 10x data, cells capture higher chance creating doublet, Chromium documentation indicates doublet rate roughly 1% per 1000 cells captures (5000 cells, (0.01*5)*5000 = 250 doublets), default expected doublet rate set value (default standard deviation 0.015). Note however different protocols may create considerably doublets, updated accordingly. unsure doublet rate, might consider increasing dbr.sd, estimated mostl/purely misclassification error.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/scDblFinder.html","id":"number-of-artificial-doublets","dir":"Articles","previous_headings":"scDblFinder > Some important parameters","what":"Number of artificial doublets","title":"scDblFinder","text":"number artificial doublets can set artificialDoublets parameter. Using artificial doublets leads better sampling possible mixtures cells, increases memory runtime, can skew scores, extreme cases leading difficulties setting threshold called doublet (see issue discussion). default, scDblFinder generate roughly many artificial doublets cells, usually appropriate. However, small datasets represent undersampling mixing space hence lead lower detection accuracy. reason, hard minimum number artificial doublet set. tend improve accuracy small datasets, scores skewed towards 1, possibly making separation difficult. situation histogram scores show bimodality, consider manually setting artificialDoublets parameter something closer actual number cells.","code":""},{"path":[]},{"path":"https://plger.github.io/scDblFinder/articles/scDblFinder.html","id":"im-getting-way-too-many-doublets-called---whats-going-on","dir":"Articles","previous_headings":"scDblFinder > Frequently-asked questions","what":"I’m getting way too many doublets called - what’s going on?","title":"scDblFinder","text":"likely wrong doublet rate. provide (dbr argument), doublet rate calculated automatically using expected doublet rates 10x, meaning cells captured, higher doublet rates. reasons think applicable data, set dbr manually. common cause unexpectedly large proportion doublets multi-sample dataset split samples. scDblFinder think data single capture loads cells, hence high doublet rate. Splitting sample solve issue. Also note , although 10X-like data tends roughly 1% per 1000 cells captured, determining factor doublet formation number cells inserted machine. reason recovery rate lower expected, might higher doublet rate ’d expect captured called cells (words, preferable say doublet rate roughly 0.6% per 1000 cells put machine, 0.6 recovery rate). circumstances, scDblFinder typically sets thresholds correctly nevertheless. thresholding tries minimize deviation expected number doublets misclassification (.e. artificial doublets), meaning effective (.e. final) doublet rate differ given one. scDblFinder also considers false positives less problematic false negatives. can reduce degree deviation input doublet rate setting dbr.sd=0.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/scDblFinder.html","id":"should-i-use-the-cluster-based-doublet-generation-or-not","dir":"Articles","previous_headings":"scDblFinder > Frequently-asked questions","what":"Should I use the cluster-based doublet generation or not?","title":"scDblFinder","text":"approaches perform similarly overall benchmarks (see scDblFinder paper). data clearly segregated clusters, interested origin doublets, cluster-based approach preferable. also enable accurate accounting homotypic doublets, therefore slightly better thresholding. Otherwise, especially data segregate clearly clusters, random approach (e.g. clusters=FALSE, default) preferable.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/scDblFinder.html","id":"the-clusters-dont-make-any-sense","dir":"Articles","previous_headings":"scDblFinder > Frequently-asked questions","what":"The clusters don’t make any sense!","title":"scDblFinder","text":"ran scDblFinder multi-sample dataset provide cluster labels, labels sample-specific (meaning label ‘1’ one sample might nothing label ‘1’ another), plotting tSNE look like make sense. reason, running multiple samples recommend first cluster samples together (example using sce$cluster <- fastcluster(sce)) provide clusters scDblFinder.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/scDblFinder.html","id":"size-factors-should-be-positive-error","dir":"Articles","previous_headings":"scDblFinder > Frequently-asked questions","what":"‘Size factors should be positive’ error","title":"scDblFinder","text":"get error cells zero reads (low read count, leading zero feature selection). filtering cells error go away.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/scDblFinder.html","id":"identifying-homotypic-doublets","dir":"Articles","previous_headings":"scDblFinder > Frequently-asked questions","what":"Identifying homotypic doublets","title":"scDblFinder","text":"Like similar tools, scDblFinder focuses identifying heterotypic doublets (formed different cell types), low performance identifying homotypic doublets (see preprint). can lead disagreements doublets called using cell hashes SNPs multiplexed samples, capture types doublets similarly (can miss intra-sample heterotypic doublets, especially multiplexing low). treat approaches complementary. However, reason try identify also homotypic doublets scDblFinder, sure use cluster-based approach, set removeUnidentifiable=FALSE. Otherwise, scDblFinder removes artificial doublets likely homotypic training, therefore focusing task heterotypic doublets, expense ot homotypic ones (typically deemed relatively harmless).","code":""},{"path":"https://plger.github.io/scDblFinder/articles/scDblFinder.html","id":"how-can-i-make-this-reproducible","dir":"Articles","previous_headings":"scDblFinder > Frequently-asked questions","what":"How can I make this reproducible?","title":"scDblFinder","text":"relies partly random generation artificial doublets, running scDblFinder multiple times data yield slightly different results. can ensure reproducibility using set.seed(), however sufficient processing multiple samples (.e. using samples argument – even without multithreading!). case, seed needs passed BPPARAMs: Similarly, processing samples serially, use SerialParam(RNGseed = seed). (Note BiocParallel versions <1.28, one addition explicitly start cluster run using bpstart(bp), bpstop(bp) scDblFinder.)","code":"bp <- MulticoreParam(3, RNGseed=1234) sce <- scDblFinder(sce, clusters=\"cluster\", samples=\"sample\", BPPARAM=bp)"},{"path":"https://plger.github.io/scDblFinder/articles/scDblFinder.html","id":"can-i-use-this-in-combination-with-seurat-or-other-tools","dir":"Articles","previous_headings":"scDblFinder > Frequently-asked questions","what":"Can I use this in combination with Seurat or other tools?","title":"scDblFinder","text":"input SCE already contains logcounts assay reducedDim slot named ‘PCA’, scDblFinder use clustering step. addition, clustering can manually given using clusters argument scDblFinder(). way, seurat clustering instance used create artificial doublets (see ?Seurat::.SingleCellExperiment.Seurat conversion SCE). example, assuming Seurat object se, following done: artificial doublets generation, counts real artificial cells must reprocessed (.e. normalization PCA) together, performed internally using scater. wish step performed differently, may provide function (see processing argument ?scDblFinder). note, however, impact variations step doublet detection rather mild. fact, performing normalization instance decreases doublet identification accuracy, rather little. example, following code enable internal use sctransform: Note however generally lead improved performance – rather decreased benchmark datasets, fact (see comparison issue).","code":"sce <- scDblFinder(GetAssayData(se, slot=\"counts\"), clusters=Idents(se)) # port the resulting scores back to the Seurat object: se$scDblFinder.score <- sce$scDblFinder.score # assuming `x` is the count matrix: nfeatures <- 1000 sce <- SingleCellExperiment(list(counts=x)) # sctransform on real cells: vst1 <- sctransform::vst(counts(sce), n_cells=min(ncol(sce),5000), verbosity=0) sce <- sce[row.names(vst1$y),] logcounts(sce) <- vst1$y hvg <- row.names(sce)[head(order(vst1$gene_attr$residual_variance, decreasing=TRUE), nfeatures)]  # define a processing function that scDblFinder will use on the real+artificial doublets; # the input should be a count matrix and the number of dimensions, and the output a PCA matrix    myfun <- function(e, dims){   # we use the thetas calculated from the first vst on real cells   e <- e[intersect(row.names(e), row.names(vst1$model_pars_fit[which(!is.na(vst1$model_pars_fit[,\"theta\"])),])),]   vst2 <- sctransform::vst(e, n_cells=min(ncol(e),5000), method=\"nb_theta_given\",                             theta_given=vst1$model_pars_fit[row.names(e),\"theta\"],                            min_cells=1L, verbosity=0)   scater::calculatePCA(vst2$y, ncomponents=dims) }    sce <- scDblFinder(sce, processing=myfun, nfeatures=hvg)"},{"path":"https://plger.github.io/scDblFinder/articles/scDblFinder.html","id":"can-this-be-used-with-scatacseq-data","dir":"Articles","previous_headings":"scDblFinder > Frequently-asked questions","what":"Can this be used with scATACseq data?","title":"scDblFinder","text":"Yes, see scATAC vignette specifically topic.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/scDblFinder.html","id":"should-i-run-qc-cell-filtering-before-or-after-doublet-detection","dir":"Articles","previous_headings":"scDblFinder > Frequently-asked questions","what":"Should I run QC cell filtering before or after doublet detection?","title":"scDblFinder","text":"input scDblFinder include empty droplets, might necessary remove cells low coverage (e.g. <200 500 reads) avoid errors. quality filtering performed downstream doublet detection, two reasons: 1. default expected doublet rate calculated basis cells given, excluded lot cells low quality, scDblFinder might think doublet rate lower . 2. kicking low quality cells first might hamper ability detect doublets formed combination good quality cell low-quality one. said, mostly theoretical grounds, unless QC filtering stringent (shouldn’t !), ’s unlikely make big difference.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/scDblFinder.html","id":"what-about-ambiant-rna-decontamination","dir":"Articles","previous_headings":"scDblFinder > Frequently-asked questions > Should I run QC cell filtering before or after doublet detection?","what":"What about ambiant RNA decontamination?","title":"scDblFinder","text":"Contamination ambiant RNA emerged important confounder single-cell (especially single-nuclei) RNAseq data, prompts question whether run prior doublet detection. Unfortunately, currently good evidence pointing either direction, arguments can made . Low-quality doublets, doublets experiment large dominant celltype, can easily look like contamination, likewise high amount contamination can easily look like doublet includes RNA cell types. possibility decontamination package sees actual doublet contamination, attempts clean , necessarily imperfectly (decontamination mixture cells, doublet isn’t), perhaps sufficiently can’t accurately detected doublet anymore. therefore argument running doublet calling first. However, ’s also possible decontamination, makes cells cleaner, makes doublet detection task easier.","code":""},{"path":"https://plger.github.io/scDblFinder/articles/scDblFinder.html","id":"can-i-combine-this-method-with-others","dir":"Articles","previous_headings":"scDblFinder > Frequently-asked questions","what":"Can I combine this method with others?","title":"scDblFinder","text":"course always possible run multiple methods combine results. benchmark, combination scDblFinder DoubletFinder, instance, yield improvement (though ) datasets (see results ), although small magnitude. simplest way average scores (assuming scores similar scale, higher score interpretation across methods), instance gave similar results using Fisher p-value combination 1-score (interpreted probability).","code":""},{"path":"https://plger.github.io/scDblFinder/articles/scDblFinder.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"scDblFinder","text":"","code":"sessionInfo() ## R version 4.4.0 (2024-04-24) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 22.04.4 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats4    stats     graphics  grDevices utils     datasets  methods   ## [8] base      ##  ## other attached packages: ##  [1] scDblFinder_1.19.0          SingleCellExperiment_1.26.0 ##  [3] SummarizedExperiment_1.34.0 Biobase_2.64.0              ##  [5] GenomicRanges_1.56.0        GenomeInfoDb_1.40.1         ##  [7] IRanges_2.38.0              S4Vectors_0.42.0            ##  [9] BiocGenerics_0.50.0         MatrixGenerics_1.16.0       ## [11] matrixStats_1.3.0           BiocStyle_2.32.0            ##  ## loaded via a namespace (and not attached): ##   [1] bitops_1.0-7              gridExtra_2.3             ##   [3] rlang_1.1.4               magrittr_2.0.3            ##   [5] scater_1.32.0             compiler_4.4.0            ##   [7] DelayedMatrixStats_1.26.0 systemfonts_1.1.0         ##   [9] vctrs_0.6.5               pkgconfig_2.0.3           ##  [11] crayon_1.5.2              fastmap_1.2.0             ##  [13] XVector_0.44.0            scuttle_1.14.0            ##  [15] utf8_1.2.4                Rsamtools_2.20.0          ##  [17] rmarkdown_2.27            UCSC.utils_1.0.0          ##  [19] ggbeeswarm_0.7.2          ragg_1.3.2                ##  [21] purrr_1.0.2               xfun_0.44                 ##  [23] bluster_1.14.0            zlibbioc_1.50.0           ##  [25] cachem_1.1.0              beachmat_2.20.0           ##  [27] jsonlite_1.8.8            DelayedArray_0.30.1       ##  [29] BiocParallel_1.38.0       irlba_2.3.5.1             ##  [31] parallel_4.4.0            cluster_2.1.6             ##  [33] R6_2.5.1                  bslib_0.7.0               ##  [35] limma_3.60.2              rtracklayer_1.64.0        ##  [37] xgboost_1.7.7.1           jquerylib_0.1.4           ##  [39] Rcpp_1.0.12               bookdown_0.39             ##  [41] knitr_1.47                Matrix_1.7-0              ##  [43] igraph_2.0.3              tidyselect_1.2.1          ##  [45] abind_1.4-5               yaml_2.3.8                ##  [47] viridis_0.6.5             codetools_0.2-20          ##  [49] curl_5.2.1                lattice_0.22-6            ##  [51] tibble_3.2.1              evaluate_0.24.0           ##  [53] desc_1.4.3                Biostrings_2.72.1         ##  [55] pillar_1.9.0              BiocManager_1.30.23       ##  [57] generics_0.1.3            RCurl_1.98-1.14           ##  [59] ggplot2_3.5.1             sparseMatrixStats_1.16.0  ##  [61] munsell_0.5.1             scales_1.3.0              ##  [63] glue_1.7.0                metapod_1.12.0            ##  [65] tools_4.4.0               BiocIO_1.14.0             ##  [67] data.table_1.15.4         BiocNeighbors_1.22.0      ##  [69] ScaledMatrix_1.12.0       locfit_1.5-9.9            ##  [71] GenomicAlignments_1.40.0  fs_1.6.4                  ##  [73] scran_1.32.0              XML_3.99-0.16.1           ##  [75] grid_4.4.0                edgeR_4.2.0               ##  [77] colorspace_2.1-0          GenomeInfoDbData_1.2.12   ##  [79] beeswarm_0.4.0            BiocSingular_1.20.0       ##  [81] restfulr_0.0.15           vipor_0.4.7               ##  [83] cli_3.6.2                 rsvd_1.0.5                ##  [85] textshaping_0.4.0         fansi_1.0.6               ##  [87] S4Arrays_1.4.1            viridisLite_0.4.2         ##  [89] dplyr_1.1.4               gtable_0.3.5              ##  [91] sass_0.4.9                digest_0.6.35             ##  [93] SparseArray_1.4.8         ggrepel_0.9.5             ##  [95] dqrng_0.4.1               rjson_0.2.21              ##  [97] memoise_2.0.1             htmltools_0.5.8.1         ##  [99] pkgdown_2.0.9             lifecycle_1.0.4           ## [101] httr_1.4.7                statmod_1.5.0             ## [103] MASS_7.3-60.2"},{"path":"https://plger.github.io/scDblFinder/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Pierre-Luc Germain. Maintainer, author. Aaron Lun. Contributor.","code":""},{"path":"https://plger.github.io/scDblFinder/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Germain P, Lun , Garcia Meixide C, Macnair W, Robinson M (2022). “Doublet identification single-cell sequencing data using scDblFinder.” f1000research. doi:10.12688/f1000research.73600.2.","code":"@Article{,   title = {Doublet identification in single-cell sequencing data using scDblFinder},   author = {Pierre-Luc Germain and Aaron Lun and Carlos {Garcia Meixide} and Will Macnair and Mark D. Robinson},   year = {2022},   journal = {f1000research},   doi = {10.12688/f1000research.73600.2}, }"},{"path":"https://plger.github.io/scDblFinder/index.html","id":"scdblfinder-","dir":"","previous_headings":"","what":"scDblFinder","title":"scDblFinder","text":"scDblFinder package gathers various methods detection handling doublets/multiplets single-cell sequencing data (.e. multiple cells captured within droplet reaction volume), including novel scDblFinder method. methods included complementary doublets detection via cell hashes SNPs multiplexed samples: hashing/genotypes can identify doublets formed cells type (homotypic doublets) two samples, often nearly undistinguishable real cells transcriptionally (hence generally unidentifiable present package), identify doublets made cells sample, even heterotypic (formed different cell types). Instead, methods presented primarily geared towards identification heterotypic doublets, purposes also critical ones. brief overview methods, see introductory vignette (vignette(\"introduction\", package=\"scDblFinder\")). detailed study including comparison alternative methods, see paper. , showcase doublet detection using fast comprehensive scDblFinder method.","code":""},{"path":[]},{"path":"https://plger.github.io/scDblFinder/index.html","id":"installation","dir":"","previous_headings":"Getting started","what":"Installation","title":"scDblFinder","text":"may install pakage using: , get latest version, latest version compatible older Bioconductor versions. Note , installing git, Bioconductor install latest version packages, (ensure compatibility packages) installs version tied Bioconductor version. ensure best results, install latest Bioconductor release. recommend avoid using scDblFinder versions prior Bioconductor 3.14, give suboptimal results, scATAC users need scDblFinder version 1.13.2 .","code":"BiocManager::install(\"scDblFinder\") BiocManager::install(\"plger/scDblFinder\")"},{"path":"https://plger.github.io/scDblFinder/index.html","id":"basic-usage","dir":"","previous_headings":"Getting started","what":"Basic usage","title":"scDblFinder","text":"Given object sce class SingleCellExperiment (contain empty drops, hasn’t filtered), can launch doublet detection : add number columns colData sce, important : sce$scDblFinder.score : final doublet score (higher likely cell doublet) sce$scDblFinder.class : classification (doublet singlet) several additional columns containing information (e.g. likely origin putative doublet), overview available vignette (vignette(\"scDblFinder\")).","code":"library(scDblFinder) sce <- scDblFinder(sce)"},{"path":"https://plger.github.io/scDblFinder/index.html","id":"multiple-samples","dir":"","previous_headings":"Getting started","what":"Multiple samples","title":"scDblFinder","text":"multiple samples (understood different cell captures, .e. multiplexed samples cell hashes, rather use batch), preferable provide scDblFinder information order take consideration batch/sample-specific doublet rates. can simply providing vector sample ids samples parameter scDblFinder , stored column colData, name column. default settings, result samples processed separately, appears faster, robust batch effects, accurate training single model (see multiSampleMode argument options). cases, might also consider multithreading using BPPARAM parameter. example:","code":"library(BiocParallel) sce <- scDblFinder(sce, samples=\"sample_id\", BPPARAM=MulticoreParam(3)) table(sce$scDblFinder.class)"},{"path":"https://plger.github.io/scDblFinder/index.html","id":"cluster-based-detection","dir":"","previous_headings":"Getting started","what":"Cluster-based detection","title":"scDblFinder","text":"scDblFinder two main modes generating artificial doublets: random one (clusters=FALSE, now default) cluster-based one (clusters=TRUE providing clusters - approach previous versions). practice, observed approaches perform well (better alternatives). suggest using cluster-based approach datasets segregated clear clusters, random one rest (e.g. developmental trajectories).","code":""},{"path":"https://plger.github.io/scDblFinder/index.html","id":"expected-proportion-of-doublets","dir":"","previous_headings":"Getting started","what":"Expected proportion of doublets","title":"scDblFinder","text":"expected proportion doublets little impact score, strong impact threshold placed (thresholding procedure simultaneously minimizes classification error departure expected doublet rate). specified dbr parameter dbr.sd parameter (latter specifies standard deviation dbr, .e. uncertainty expected doublet rate). 10x data, cells capture higher chance creating doublet, Chromium documentation indicates doublet rate roughly 1% per 1000 cells captures (5000 cells, (0.01*5)*5000 = 250 doublets), default expected doublet rate set value (default standard deviation 0.015). Note however different protocols may create considerably doublets, updated accordingly. unsure doublet rate, set dbr.sd=1 thresholding entirely based misclassification rates.","code":""},{"path":"https://plger.github.io/scDblFinder/index.html","id":"single-cell-atacseq","dir":"","previous_headings":"","what":"Single-cell ATACseq","title":"scDblFinder","text":"scDblFinder method can single-cell ATACseq (peak-level counts), however recommend using aggregateFeatures=TRUE parameter (see vignette). addition, package includes reimplementation Amulet method Thibodeau et al. (2021). information, see ATAC-related vignette.","code":""},{"path":"https://plger.github.io/scDblFinder/index.html","id":"comparison-with-other-tools","dir":"","previous_headings":"","what":"Comparison with other tools","title":"scDblFinder","text":"scDblFinder independently evaluated Nan Miles Xi Jingyi Jessica Li addendum excellent benchmark, write “scDblFinder achieves highest mean AUPRC AUROC values, also top method terms precision, recall, TNR 10% identification rate.” figure compares methods implemented package (bold) alternative methods (including top alternative, DoubletFinder): Figure1: Accuracy (area precision recall curve) doublet identification using alternative methods across 16 benchmark datasets Xi Li (2020). colour dots indicates relative ranking dataset, size numbers indicate actual area (PR) curve. dataset, top method circled black. Methods names black provided scDblFinder package. Running times indicated left. top number cells dataset shown, colored proportion variance explained first two components (relative explained first 100), rough guide dataset simplicity.  Rather python person? can look vaeda, another doublet finding method appears performances close scDblFinder.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/TFIDF.html","id":null,"dir":"Reference","previous_headings":"","what":"TFIDF — TFIDF","title":"TFIDF — TFIDF","text":"Term Frequency - Inverse Document Frequency (TF-IDF) normalization, implemented Stuart & Butler et al. 2019.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/TFIDF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"TFIDF — TFIDF","text":"","code":"TFIDF(x, sf = 10000)"},{"path":"https://plger.github.io/scDblFinder/reference/TFIDF.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"TFIDF — TFIDF","text":"x matrix occurrences sf Scaling factor","code":""},{"path":"https://plger.github.io/scDblFinder/reference/TFIDF.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"TFIDF — TFIDF","text":"array dimensions `x`","code":""},{"path":"https://plger.github.io/scDblFinder/reference/TFIDF.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"TFIDF — TFIDF","text":"","code":"m <- matrix(rpois(500,1),nrow=50) m <- TFIDF(m)"},{"path":"https://plger.github.io/scDblFinder/reference/addDoublets.html","id":null,"dir":"Reference","previous_headings":"","what":"addDoublets — addDoublets","title":"addDoublets — addDoublets","text":"Adds artificial doublets existing dataset","code":""},{"path":"https://plger.github.io/scDblFinder/reference/addDoublets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"addDoublets — addDoublets","text":"","code":"addDoublets(   x,   clusters,   dbr = (0.01 * ncol(x)/1000),   only.heterotypic = TRUE,   adjustSize = FALSE,   prefix = \"doublet.\",   ... )"},{"path":"https://plger.github.io/scDblFinder/reference/addDoublets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"addDoublets — addDoublets","text":"x count matrix singlets, SummarizedExperiment-class clusters vector cluster labels column `x` dbr doublet rate .heterotypic Whether add heterotypic doublets. adjustSize Whether adjust library sizes doublets. prefix Prefix colnames generated. ... arguments createDoublets.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/addDoublets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"addDoublets — addDoublets","text":"`SingleCellExperiment` colData columns `cluster` `type` (indicating whether cell singlet doublet).","code":""},{"path":"https://plger.github.io/scDblFinder/reference/addDoublets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"addDoublets — addDoublets","text":"","code":"sce <- mockDoubletSCE(dbl.rate=0) sce <- addDoublets(sce, clusters=sce$cluster)"},{"path":"https://plger.github.io/scDblFinder/reference/aggregateFeatures.html","id":null,"dir":"Reference","previous_headings":"","what":"aggregateFeatures — aggregateFeatures","title":"aggregateFeatures — aggregateFeatures","text":"Aggregates similar features (rows).","code":""},{"path":"https://plger.github.io/scDblFinder/reference/aggregateFeatures.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"aggregateFeatures — aggregateFeatures","text":"","code":"aggregateFeatures(   x,   dims.use = seq(2L, 12L),   k = 1000,   num_init = 3,   use.mbk = NULL,   use.subset = 20000,   minCount = 1L,   norm.fn = TFIDF,   twoPass = FALSE,   ... )"},{"path":"https://plger.github.io/scDblFinder/reference/aggregateFeatures.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"aggregateFeatures — aggregateFeatures","text":"x integer/numeric (sparse) matrix, `SingleCellExperiment` including `counts` assay. dims.use PCA dimensions use clustering rows. k approximate number meta-features desired num_init number initializations used k-means clustering. use.mbk Logical; whether use minibatch k-means (see mbkmeans). NULL, minibatch approach used 30000 features. use.subset many cells (columns) use cluster features. minCount minimum number counts region included. norm.fn normalization function use un-clustered data (function taking count matrix single argument returning matrix dimensions). TFIDF default. twoPass Logical; whether perform procedure twice,  second round cells aggregated based meta-features first  round, re-clustering features. Ignored dataset fewer `use.subset` cells. ... Passed mbkmeans. Can instance used pass `BPPARAM` argument multithreading.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/aggregateFeatures.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"aggregateFeatures — aggregateFeatures","text":"aggregated version `x` (either array `SingleCellExperiment`, depending input). `x`  `SingleCellExperiment`, feature clusters also stored  `metadata(x)$featureGroups`","code":""},{"path":"https://plger.github.io/scDblFinder/reference/amulet.html","id":null,"dir":"Reference","previous_headings":"","what":"amulet — amulet","title":"amulet — amulet","text":"ATACseq (Thibodeau, Eroglu, et al., Genome Biology 2021). rationale cells unexpectedly many loci covered two reads  likely doublets.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/amulet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"amulet — amulet","text":"","code":"amulet(x, ...)"},{"path":"https://plger.github.io/scDblFinder/reference/amulet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"amulet — amulet","text":"x path fragments file, GRanges object containing fragments (`name` column containing barcode, `score` column containing count). ... argument getFragmentOverlaps.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/amulet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"amulet — amulet","text":"data.frame including, barcode, number sites covered   two reads, number reads, p- q-values (low values   indicative doublets).","code":""},{"path":"https://plger.github.io/scDblFinder/reference/amulet.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"amulet — amulet","text":"used normal (compressed) fragment files,  implementation relatively fast (except reading data)  large memory footprint since overlaps performed memory.  therefore recommended compress fragment files using bgzip index Tabix; case chromosome read processed  separately, leading considerably lower memory footprint. See  underlying getFragmentOverlaps details.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/amulet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"amulet — amulet","text":"","code":"# here we use a dummy fragment file for example: fragfile <- system.file( \"extdata\", \"example_fragments.tsv.gz\",                          package=\"scDblFinder\" ) res <- amulet(fragfile) #> Fragment file is not tabix-indexed, requiring thewhole file to be imported in memory. #> 17:27:28 - Splitting and subsetting barcodes... #> 17:27:28 - Obtaining overlaps..."},{"path":"https://plger.github.io/scDblFinder/reference/amuletFromCounts.html","id":null,"dir":"Reference","previous_headings":"","what":"amuletFromCounts — amuletFromCounts","title":"amuletFromCounts — amuletFromCounts","text":"reimplementation Amulet doublet detection method single-cell  ATACseq (Thibodeau, Eroglu, et al., Genome Biology 2021), based tile/peak  counts. Note fast approximation original Amulet  method, *performs considerably worse*; equivalent implementation,  see amulet.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/amuletFromCounts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"amuletFromCounts — amuletFromCounts","text":"","code":"amuletFromCounts(x, maxWidth = 500L, exclude = c(\"chrM\", \"M\", \"Mt\"))"},{"path":"https://plger.github.io/scDblFinder/reference/amuletFromCounts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"amuletFromCounts — amuletFromCounts","text":"x `SingleCellExperiment` object, matrix counts cells columns. rows represent peaks, recommended limite width (see details). maxWidth maximum width feature included.  ignored unless `x` `SingleCellExperiment` `rowRanges`. exclude optional `GRanges` regions excluded.  ignored unless `x` `SingleCellExperiment` `rowRanges`.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/amuletFromCounts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"amuletFromCounts — amuletFromCounts","text":"`x` `SingleCellExperiment`, returns object  additional `amuletFromCounts.q` colData column. Otherwise returns vector  amulet doublet q-values cell.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/amuletFromCounts.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"amuletFromCounts — amuletFromCounts","text":"rationale amulet method single diploid cell  two reads covering single genomic location, method  looks cells enriched sites covered two reads. method applied peak-level count matrix, however, larger peaks can however contain multiple reads even though single nucleotide  covered . Therefore, case recommend limit  width peaks used analysis, ideally maximum twice upper bound fragment size. example, mean fragment size 250bp  standard deviation 125bp, peaks larger 500bp likely  contain non-overlapping fragments, therefore excluded using `maxWidth` argument.","code":""},{"path":[]},{"path":"https://plger.github.io/scDblFinder/reference/amuletFromCounts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"amuletFromCounts — amuletFromCounts","text":"","code":"x <- mockDoubletSCE() x <- amuletFromCounts(x) table(call=x$amuletFromCounts.q<0.05, truth=x$type) #>        truth #> call    singlet doublet #>   FALSE     500       0 #>   TRUE        0      22"},{"path":"https://plger.github.io/scDblFinder/reference/clamulet.html","id":null,"dir":"Reference","previous_headings":"","what":"clamulet — clamulet","title":"clamulet — clamulet","text":"Classification-powered Amulet-like method","code":""},{"path":"https://plger.github.io/scDblFinder/reference/clamulet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"clamulet — clamulet","text":"","code":"clamulet(   x,   artificialDoublets = NULL,   iter = 2,   k = NULL,   minCount = 0.001,   maxN = 500,   nfeatures = 25,   max_depth = 5,   threshold = 0.75,   returnAll = FALSE,   verbose = TRUE,   ... )"},{"path":"https://plger.github.io/scDblFinder/reference/clamulet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"clamulet — clamulet","text":"x path fragment file (see getFragmentOverlaps performance/memory-related guidelines) artificialDoublets number artificial doublets generate iter number learning iterations (1 ) k number(s) nearest neighbors gather statistics minCount minimum number cells locus detected considered. lower 1, interpreted fraction  number cells. maxN maximum number regions per cell consider establish windows meta-features nfeatures number meta-features consider max_depth maximum tree depth threshold score threshold used iterations returnAll Logical; whether return data also artificial doublets verbose Logical; whether print progress information ... Arguments passed getFragmentOverlaps","code":""},{"path":"https://plger.github.io/scDblFinder/reference/clamulet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"clamulet — clamulet","text":"data.frame","code":""},{"path":"https://plger.github.io/scDblFinder/reference/clamulet.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"clamulet — clamulet","text":"`clamulet` operates similarly `scDblFinder` method, generates  doublets operating fragment coverages. advantage number loci covered two reads can computed  artificial doublets, enabling use feature (along  kNN-based ones) classification scheme. however disadvantage rather slow memory hungry, appears outperformed simple p-value combination two methods (see vignette).","code":""},{"path":"https://plger.github.io/scDblFinder/reference/clusterStickiness.html","id":null,"dir":"Reference","previous_headings":"","what":"clusterStickiness — clusterStickiness","title":"clusterStickiness — clusterStickiness","text":"Tests enrichment doublets created cluster (.e. cluster's stickiness). applicable >=4 clusters. Note applied multisample object, functions assumes cluster labels match across samples.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/clusterStickiness.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"clusterStickiness — clusterStickiness","text":"","code":"clusterStickiness(   x,   type = c(\"quasibinomial\", \"nbinom\", \"binomial\", \"poisson\"),   inclDiff = NULL,   verbose = TRUE )"},{"path":"https://plger.github.io/scDblFinder/reference/clusterStickiness.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"clusterStickiness — clusterStickiness","text":"x table double statistics, SingleCellExperiment scDblFinder run using cluster-based approach. type type test use (quasibinomial recommended). inclDiff Logical; whether include difficulty model. NULL, used significant trend enrichment. verbose Logical; whether print additional running information.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/clusterStickiness.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"clusterStickiness — clusterStickiness","text":"table test results cluster.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/clusterStickiness.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"clusterStickiness — clusterStickiness","text":"","code":"sce <- mockDoubletSCE(rep(200,5)) sce <- scDblFinder(sce, clusters=TRUE, artificialDoublets=500) #> Warning: Some cells in `sce` have an extremely low read counts; note that these could trigger errors and might best be filtered out #> Clustering cells... #> 5 clusters #> Creating ~500 artificial doublets... #> Dimensional reduction #> Evaluating kNN... #> Training model... #> iter=0, 83 cells excluded from training. #> iter=1, 0 cells excluded from training. #> iter=2, 0 cells excluded from training. #> Threshold found:0.997 #> 0 (0%) doublets called clusterStickiness(sce) #> Error in family$linkfun(mustart): Argument mu must be a nonempty numeric vector"},{"path":"https://plger.github.io/scDblFinder/reference/computeDoubletDensity.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the density of simulated doublets — computeDoubletDensity","title":"Compute the density of simulated doublets — computeDoubletDensity","text":"Identify potential doublet cells based local density simulated doublet expression profiles. replaces older doubletCells function scran package.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/computeDoubletDensity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the density of simulated doublets — computeDoubletDensity","text":"","code":"computeDoubletDensity(x, ...)  # S4 method for ANY computeDoubletDensity(   x,   size.factors.norm = NULL,   size.factors.content = NULL,   k = 50,   subset.row = NULL,   niters = max(10000, ncol(x)),   block = 10000,   dims = 25,   BNPARAM = KmknnParam(),   BSPARAM = bsparam(),   BPPARAM = SerialParam() )  # S4 method for SummarizedExperiment computeDoubletDensity(x, ..., assay.type = \"counts\")  # S4 method for SingleCellExperiment computeDoubletDensity(x, size.factors.norm = sizeFactors(x), ...)"},{"path":"https://plger.github.io/scDblFinder/reference/computeDoubletDensity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the density of simulated doublets — computeDoubletDensity","text":"x numeric matrix-like object count values,  column corresponds cell row corresponds endogenous gene. Alternatively, SummarizedExperiment SingleCellExperiment object containing matrix. ... generic, additional arguments pass specific methods. SummarizedExperiment SingleCellExperiment methods, additional arguments pass method. size.factors.norm numeric vector size factors normalization x prior PCA distance calculations. NULL, defaults size factors derived library sizes x. SingleCellExperiment method, default values taken sizeFactors(x), available. size.factors.content numeric vector size factors RNA content normalization x prior simulating doublets. orthogonal values size.factors.norm, see Details. k integer scalar specifying number nearest neighbours use determine bandwidth density calculations. subset.row See ?\"scran-gene-selection\". niters integer scalar specifying many simulated doublets generated. block integer scalar controlling rate doublet generation, keep memory usage low. dims integer scalar specifying number components retain PCA. BNPARAM BiocNeighborParam object specifying nearest neighbor algorithm. algorithm supported findNeighbors. BSPARAM BiocSingularParam object specifying algorithm use PCA, d NA. BPPARAM BiocParallelParam object specifying whether neighbour searches parallelized. assay.type string specifying assay values contain count matrix.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/computeDoubletDensity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the density of simulated doublets — computeDoubletDensity","text":"numeric vector doublet scores cell x.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/computeDoubletDensity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute the density of simulated doublets — computeDoubletDensity","text":"function simulates doublets adding count vectors two randomly chosen cells x. original cell, compute density neighboring simulated doublets compare density neighboring original cells. Genuine doublets high density simulated doublets relative density neighbourhood. Thus, doublet score cell defined ratio densities simulated doublets density original cells. Densities calculated low-dimensional space PCA log-normalized expression matrix x. Simulated doublets projected low-dimensional space using rotation vectors computed original cells. cell, density simulated doublets computed hypersphere radius set median distance k nearest neighbour. normalized niters, k total number cells x yield final score. two size factor arguments different roles: size.factors.norm contains size factors used normalization prior PCA distance calculations. defaults values returned librarySizeFactors can explicitly set ensure low-dimensional space consistent rest analysis. size.factors.content much important, represents size factors preserve RNA content differences. usually computed spike-RNA ensures simulated doublets correct ratio contributions original cells. possible set arguments orthogonal . Setting size.factors.content affect calculation log-normalized expression values x. Conversely, setting size.factors.norm affect ratio cells added together simulating doublets.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/computeDoubletDensity.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute the density of simulated doublets — computeDoubletDensity","text":"Lun ATL (2018). Detecting doublet cells scran. https://ltla.github.io/SingleCellThoughts/software/doublet_detection/bycell.html","code":""},{"path":[]},{"path":"https://plger.github.io/scDblFinder/reference/computeDoubletDensity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute the density of simulated doublets — computeDoubletDensity","text":"Aaron Lun","code":""},{"path":"https://plger.github.io/scDblFinder/reference/computeDoubletDensity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute the density of simulated doublets — computeDoubletDensity","text":"","code":"# Mocking up an example. set.seed(100) ngenes <- 1000 mu1 <- 2^rnorm(ngenes) mu2 <- 2^rnorm(ngenes) mu3 <- 2^rnorm(ngenes) mu4 <- 2^rnorm(ngenes)  counts.1 <- matrix(rpois(ngenes*100, mu1), nrow=ngenes) # Pure type 1 counts.2 <- matrix(rpois(ngenes*100, mu2), nrow=ngenes) # Pure type 2 counts.3 <- matrix(rpois(ngenes*100, mu3), nrow=ngenes) # Pure type 3 counts.4 <- matrix(rpois(ngenes*100, mu4), nrow=ngenes) # Pure type 4 counts.m <- matrix(rpois(ngenes*20, mu1+mu2), nrow=ngenes) # Doublets (1 & 2)  counts <- cbind(counts.1, counts.2, counts.3, counts.4, counts.m) clusters <- rep(1:5, c(rep(100, 4), ncol(counts.m)))  # Find potential doublets. scores <- computeDoubletDensity(counts) boxplot(split(log10(scores), clusters))"},{"path":"https://plger.github.io/scDblFinder/reference/createDoublets.html","id":null,"dir":"Reference","previous_headings":"","what":"createDoublets — createDoublets","title":"createDoublets — createDoublets","text":"Creates artificial doublet cells combining given pairs cells","code":""},{"path":"https://plger.github.io/scDblFinder/reference/createDoublets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"createDoublets — createDoublets","text":"","code":"createDoublets(   x,   dbl.idx,   clusters = NULL,   resamp = 0.5,   halfSize = 0.5,   adjustSize = FALSE,   prefix = \"dbl.\" )"},{"path":"https://plger.github.io/scDblFinder/reference/createDoublets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"createDoublets — createDoublets","text":"x count matrix real cells dbl.idx matrix data.frame pairs cell indexes stored first two columns. clusters optional vector cluster labels (column `x`) resamp Logical; whether resample doublets using poisson distribution. Alternatively, proportion 0 1, proportion doublets resample. halfSize Logical; whether half library size doublets (instead just summing cells). Alternatively, number 0 1 can given, determining proportion doublets perform size adjustment. Ignored resampling. adjustSize Logical; whether adjust size doublets using median sizes per cluster originating cells. Requires `clusters` given. Alternatively logical value, number 0 1 can given, determining proportion doublets perform size adjustment. prefix Prefix colnames generated.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/createDoublets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"createDoublets — createDoublets","text":"matrix artificial doublets.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/createDoublets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"createDoublets — createDoublets","text":"","code":"sce <- mockDoubletSCE() idx <- getCellPairs(sce$cluster, n=200) art.dbls <- createDoublets(sce, idx)"},{"path":"https://plger.github.io/scDblFinder/reference/cxds2.html","id":null,"dir":"Reference","previous_headings":"","what":"cxds2 — cxds2","title":"cxds2 — cxds2","text":"Calculates coexpression-based doublet score using method developed Bais Kostka 2020. original implementation scds package, enabling scores calculated cells gene coexpression based subset (.e. excluding known/artificial  doublets) making robust low sparsity.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/cxds2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"cxds2 — cxds2","text":"","code":"cxds2(x, whichDbls = c(), ntop = 500, binThresh = NULL)"},{"path":"https://plger.github.io/scDblFinder/reference/cxds2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"cxds2 — cxds2","text":"x matrix counts, `SingleCellExperiment` containing 'counts' whichDbls columns `x` known doublets. ntop number top features keep. binThresh count threshold considered expressed.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/cxds2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"cxds2 — cxds2","text":"cxds score , `x` `SingleCellExperiment`, `x`   added `cxds_score` colData column.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/cxds2.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"cxds2 — cxds2","text":"https://doi.org/10.1093/bioinformatics/btz698","code":""},{"path":"https://plger.github.io/scDblFinder/reference/cxds2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"cxds2 — cxds2","text":"","code":"sce <- mockDoubletSCE() sce <- cxds2(sce) # which is equivalent to # sce$cxds_score <- cxds2(counts(sce))"},{"path":"https://plger.github.io/scDblFinder/reference/directDblClassification.html","id":null,"dir":"Reference","previous_headings":"","what":"directClassification — directDblClassification","title":"directClassification — directDblClassification","text":"Trains classifier directly expression matrix distinguish artificial doublets real cells.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/directDblClassification.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"directClassification — directDblClassification","text":"","code":"directDblClassification(   sce,   dbr = NULL,   processing = \"default\",   iter = 2,   dims = 20,   nrounds = 0.25,   max_depth = 6,   ... )"},{"path":"https://plger.github.io/scDblFinder/reference/directDblClassification.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"directClassification — directDblClassification","text":"sce SummarizedExperiment-class, SingleCellExperiment-class, array counts. dbr expected doublet rate. default assumed 1% per thousand cells captured (4% among 4000 thousand cells), appropriate 10x datasets. Corrections homeotypic doublets performed given rate. processing Counts (real artificial) processing. Either 'default' (normal scater-based normalization PCA), \"rawPCA\" (PCA without normalization), \"rawFeatures\" (normalization/dimensional reduction), \"normFeatures\" (uses normalized features, without PCA) custom function (least) arguments `e` (matrix counts) `dims` (desired number dimensions), returning named matrix cells rows components columns. iter positive integer indicating number scoring iterations. iteration, real cells called doublets excluding training, new scores calculated. dims number dimensions used. nrounds Maximum rounds boosting. NULL, determined cross-validation. max_depth Maximum depths tree. ... doublet generation pre-processing argument passed `scDblFinder`.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/directDblClassification.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"directClassification — directDblClassification","text":"SummarizedExperiment-class additional `colData` column `directDoubletScore`.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/directDblClassification.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"directClassification — directDblClassification","text":"","code":"sce <- directDblClassification(mockDoubletSCE(), artificialDoublets=1) #> Creating ~517 artificial doublets... #> Round 1: 17 excluded from training. #> Round 2: 17 excluded from training. boxplot(sce$directDoubletScore~sce$type)"},{"path":"https://plger.github.io/scDblFinder/reference/doubletPairwiseEnrichment.html","id":null,"dir":"Reference","previous_headings":"","what":"doubletPairwiseEnrichment — doubletPairwiseEnrichment","title":"doubletPairwiseEnrichment — doubletPairwiseEnrichment","text":"Calculates enrichment type doublet (.e. specific combination clusters) random expectation. Note applied multisample object, functions assumes cluster labels match across samples.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/doubletPairwiseEnrichment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"doubletPairwiseEnrichment — doubletPairwiseEnrichment","text":"","code":"doubletPairwiseEnrichment(   x,   lower.tail = FALSE,   sampleWise = FALSE,   type = c(\"poisson\", \"binomial\", \"nbinom\", \"chisq\"),   inclDiff = TRUE,   verbose = TRUE )"},{"path":"https://plger.github.io/scDblFinder/reference/doubletPairwiseEnrichment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"doubletPairwiseEnrichment — doubletPairwiseEnrichment","text":"x table double statistics, SingleCellExperiment scDblFinder run using cluster-based approach. lower.tail Logical; defaults FALSE test enrichment (instead depletion). sampleWise Logical; whether perform tests sample-wise multi-sample datasets. FALSE (default), aggregate counts testing. type Type test use. inclDiff Logical; whether regress effect identification difficulty calculating expected counts verbose Logical; whether output eventual warnings/notes","code":""},{"path":"https://plger.github.io/scDblFinder/reference/doubletPairwiseEnrichment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"doubletPairwiseEnrichment — doubletPairwiseEnrichment","text":"table significances combination.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/doubletPairwiseEnrichment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"doubletPairwiseEnrichment — doubletPairwiseEnrichment","text":"","code":"sce <- mockDoubletSCE() sce <- scDblFinder(sce, clusters=TRUE, artificialDoublets=500) #> Warning: Some cells in `sce` have an extremely low read counts; note that these could trigger errors and might best be filtered out #> Clustering cells... #> 4 clusters #> Creating ~500 artificial doublets... #> Dimensional reduction #> Evaluating kNN... #> Training model... #> iter=0, 17 cells excluded from training. #> iter=1, 17 cells excluded from training. #> iter=2, 17 cells excluded from training. #> Threshold found:0.814 #> 17 (3.2%) doublets called doubletPairwiseEnrichment(sce) #> theta=0.0982616714523507 #>   combination  log2enrich      p.value          FDR #> 3         2+3  1.50334955 0.0001418108 0.0008508647 #> 5         2+4  0.09494413 0.2175146578 1.0000000000 #> 1         1+2  0.20678984 0.2466576257 1.0000000000 #> 2         1+3 -2.02625514 1.0000000000 1.0000000000 #> 4         1+4 -0.97004127 1.0000000000 1.0000000000 #> 6         3+4 -0.60094404 1.0000000000 1.0000000000"},{"path":"https://plger.github.io/scDblFinder/reference/doubletThresholding.html","id":null,"dir":"Reference","previous_headings":"","what":"doubletThresholding — doubletThresholding","title":"doubletThresholding — doubletThresholding","text":"Sets doublet scores threshold; typically called scDblFinder.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/doubletThresholding.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"doubletThresholding — doubletThresholding","text":"","code":"doubletThresholding(   d,   dbr = NULL,   dbr.sd = NULL,   stringency = 0.5,   p = 0.1,   method = c(\"auto\", \"optim\", \"dbr\", \"griffiths\"),   perSample = TRUE,   returnType = c(\"threshold\", \"call\") )"},{"path":"https://plger.github.io/scDblFinder/reference/doubletThresholding.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"doubletThresholding — doubletThresholding","text":"d data.frame cell properties, row representing cell, produced `scDblFinder(..., returnType=\"table\")`, minimally containing `score` column. dbr expected (mean) doublet rate. `d` contains `cluster` column, doublet rate adjusted homotypic doublets. dbr.sd standard deviation doublet rate, representing uncertainty estimate. Ignored `method!=\"optim\"`. stringency numeric value >0 <1 controls relative weight false positives (.e. real cells) false negatives (artificial doublets) setting threshold. value 0.5 gives equal weight ; higher value (e.g. 0.7) gives higher weight false positives, lower artificial doublets.  Ignored `method!=\"optim\"`. p p-value threshold determining deviation doublet score. method thresholding method use, either 'auto' (default, automatic selection depending available fields), 'optim' (optimization misclassification rate deviation expected doublet rate), 'dbr' (strictly based expected doublet rate), 'griffiths' (cluster-wise number median absolute deviation doublet score). perSample Logical; whether perform thresholding individually sample. returnType type value return, either doublet calls (`call`) thresholds (`threshold`).","code":""},{"path":"https://plger.github.io/scDblFinder/reference/doubletThresholding.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"doubletThresholding — doubletThresholding","text":"vector doublet calls `returnType==\"call\"`, threshold (vector thresholds) `returnType==\"threshold\"`.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/doubletThresholding.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"doubletThresholding — doubletThresholding","text":"","code":"sce <- mockDoubletSCE() d <- scDblFinder(sce, verbose=FALSE, returnType=\"table\") th <- doubletThresholding(d, dbr=0.05) th #> [1] 0.6121674"},{"path":"https://plger.github.io/scDblFinder/reference/fastcluster.html","id":null,"dir":"Reference","previous_headings":"","what":"fastcluster — fastcluster","title":"fastcluster — fastcluster","text":"Performs fast two-step clustering: first clusters using k-means large k, uses louvain clustering k cluster averages reports back cluster labels.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/fastcluster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"fastcluster — fastcluster","text":"","code":"fastcluster(   x,   k = NULL,   rdname = \"PCA\",   nstart = 3,   iter.max = 50,   ndims = NULL,   nfeatures = 1000,   verbose = TRUE,   returnType = c(\"clusters\", \"preclusters\", \"metacells\", \"graph\"),   ... )"},{"path":"https://plger.github.io/scDblFinder/reference/fastcluster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"fastcluster — fastcluster","text":"x object class SCE k number k-means clusters use primary step (much higher number expected clusters). Defaults 1/10th number cells maximum 3000. rdname name dimensionality reduction use. nstart Number starts k-means clustering iter.max Number iterations k-means clustering ndims Number dimensions use nfeatures Number features use (ignored `rdname` given corresponding dimensional reduction exists `sce`) verbose Logical; whether output progress messages returnType See return. ... Arguments passed `scater::runPCA` (e.g. BPPARAM BSPARAM) `x` `rdname`.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/fastcluster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"fastcluster — fastcluster","text":"default, vector cluster labels. `returnType='preclusters'`, returns k-means pre-clusters. `returnType='metacells'`, returns metacells aggretated pre-clusters corresponding cell indexes. `returnType='graph'`, returns graph (meta-)cells corresponding cell indexes.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/fastcluster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"fastcluster — fastcluster","text":"","code":"sce <- mockDoubletSCE() sce$cluster <- fastcluster(sce) #> Reduced dimension not found - running PCA... #> Building KNN graph and clustering"},{"path":"https://plger.github.io/scDblFinder/reference/findDoubletClusters.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect doublet clusters — findDoubletClusters","title":"Detect doublet clusters — findDoubletClusters","text":"Identify potential clusters doublet cells based whether intermediate expression profiles, .e., profiles lie two “source” clusters.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/findDoubletClusters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect doublet clusters — findDoubletClusters","text":"","code":"findDoubletClusters(x, ...)  # S4 method for ANY findDoubletClusters(   x,   clusters,   subset.row = NULL,   threshold = 0.05,   get.all.pairs = FALSE,   ... )  # S4 method for SummarizedExperiment findDoubletClusters(x, ..., assay.type = \"counts\")  # S4 method for SingleCellExperiment findDoubletClusters(x, clusters = colLabels(x, onAbsence = \"error\"), ...)"},{"path":"https://plger.github.io/scDblFinder/reference/findDoubletClusters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect doublet clusters — findDoubletClusters","text":"x numeric matrix-like object count values, column corresponds cell row corresponds endogenous gene. Alternatively, SummarizedExperiment SingleCellExperiment object containing matrix. ... generic, additional arguments pass specific methods. method, additional arguments pass findMarkers. SummarizedExperiment method, additional arguments pass method. SingleCellExperiment method, additional arguments pass SummarizedExperiment method. clusters vector length equal ncol(x), containing cluster identities cells. x SingleCellExperiment, taken colLabels(x) default. subset.row See ?\"scran-gene-selection\". threshold numeric scalar specifying FDR threshold identify significant genes. get..pairs Logical scalar indicating whether statistics possible source pairings returned. assay.type string specifying assay values use, e.g., \"counts\" \"logcounts\".","code":""},{"path":"https://plger.github.io/scDblFinder/reference/findDoubletClusters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect doublet clusters — findDoubletClusters","text":"DataFrame containing one row per query cluster following fields: source1: String specifying identity first source cluster. source2: String specifying identity second source cluster. num.de: Integer, number genes significantly non-intermediate query cluster compared two putative source clusters. median.de: Integer, median number genes significantly non-intermediate query cluster across possible source cluster pairings. best: String specifying identify top gene lowest p-value doublet hypothesis combination query source clusters. p.value: Numeric, containing adjusted p-value best gene. lib.size1: Numeric, ratio median library sizes first source cluster query cluster. lib.size2: Numeric, ratio median library sizes second source cluster query cluster. prop: Numeric, proportion cells query cluster. .pairs: SimpleList object containing statistics every pair potential source clusters, get..pairs=TRUE. row named according query cluster.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/findDoubletClusters.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Detect doublet clusters — findDoubletClusters","text":"function detects clusters doublet cells manner similar method used Bach et al. (2017). “query” cluster, examine possible pairs “source” clusters, hypothesizing query consists doublets formed two sources. , gene expression query cluster strictly intermediate two sources library size normalization. apply pairwise t-tests normalized log-expression profiles reject null hypothesis. done identifying genes consistently - -regulated query compared sources. count number genes reject null hypothesis specified FDR threshold. query cluster, likely pair source clusters minimizes number significant genes. Potential doublet clusters identified using following characteristics, order importance: Low number significant genes (.e., num.de). Ideally, median.de also high indicate absence strong DE due lack power. reasonable proportion cells cluster, .e., prop. requires expectation doublet rate experimental protocol. Library sizes source clusters query cluster, .e., lib.size* values unity. assumes doublet cluster contain RNA counts either two source clusters. query cluster, function report pair source clusters lowest num.de. Setting get..pairs=TRUE retrieve statistics pairs potential source clusters. can helpful diagnostics identify relationships specific clusters. reported p.value little use statistical sense, provided inspection. Technically, treated Simes combined p-value doublet hypothesis query cluster. However, account multiple testing across pairs clusters chosen cluster, especially chosing pair concordant doublet null hypothesis. use library size normalization (via librarySizeFactors) even existing size factors present. intermediate expression doublet cluster guaranteed arbitrary size factors. example, expression doublet cluster higher source clusters normalization performed spike-size factors.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/findDoubletClusters.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Detect doublet clusters — findDoubletClusters","text":"Bach K, Pensa S, Grzelak M, Hadfield J, Adams DJ, Marioni JC Khaled WT (2017). Differentiation dynamics mammary epithelial cells revealed single-cell RNA sequencing. Nat Commun. 8, 1:2128.","code":""},{"path":[]},{"path":"https://plger.github.io/scDblFinder/reference/findDoubletClusters.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Detect doublet clusters — findDoubletClusters","text":"Aaron Lun","code":""},{"path":"https://plger.github.io/scDblFinder/reference/findDoubletClusters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect doublet clusters — findDoubletClusters","text":"","code":"# Mocking up an example. library(SingleCellExperiment) sce <- mockDoubletSCE(c(200,300,200))  # Compute doublet-ness of each cluster: dbl <- findDoubletClusters(counts(sce), sce$cluster) dbl #> DataFrame with 3 rows and 9 columns #>              source1     source2    num.de median.de        best      p.value #>          <character> <character> <integer> <integer> <character>    <numeric> #> cluster1    cluster3    cluster2        90        90      gene12  4.73777e-94 #> cluster2    cluster3    cluster1        90        90     gene171 1.11151e-101 #> cluster3    cluster2    cluster1       112       112      gene27  3.50989e-74 #>          lib.size1 lib.size2      prop #>          <numeric> <numeric> <numeric> #> cluster1  1.096267  1.064833  0.308311 #> cluster2  1.029520  0.939114  0.423592 #> cluster3  0.971326  0.912186  0.268097  # Narrow this down to clusters with very low 'N': library(scuttle) isOutlier(dbl$num.de, log=TRUE, type=\"lower\") #> [1] FALSE FALSE FALSE #> attr(,\"class\") #> [1] \"outlier.filter\" \"logical\"        #> attr(,\"thresholds\") #>  lower higher  #>     90    Inf   # Get help from \"lib.size\" below 1. dbl$lib.size1 < 1 & dbl$lib.size2 < 1 #> [1] FALSE FALSE  TRUE"},{"path":"https://plger.github.io/scDblFinder/reference/getArtificialDoublets.html","id":null,"dir":"Reference","previous_headings":"","what":"getArtificialDoublets — getArtificialDoublets","title":"getArtificialDoublets — getArtificialDoublets","text":"Create expression profiles random artificial doublets.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/getArtificialDoublets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getArtificialDoublets — getArtificialDoublets","text":"","code":"getArtificialDoublets(   x,   n = 3000,   clusters = NULL,   resamp = 0.25,   halfSize = 0.25,   adjustSize = 0.25,   propRandom = 0.1,   selMode = c(\"proportional\", \"uniform\", \"sqrt\"),   n.meta.cells = 2,   meta.triplets = TRUE,   trim.q = c(0.05, 0.95) )"},{"path":"https://plger.github.io/scDblFinder/reference/getArtificialDoublets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getArtificialDoublets — getArtificialDoublets","text":"x count matrix, features rows cells columns. n approximate number doublet generate (default 3000). clusters optional clusters labels use build cross-cluster doublets. resamp Logical; whether resample doublets using poisson distribution. Alternatively, proportion 0 1, proportion doublets resample. halfSize Logical; whether half library size doublets (instead just summing cells). Alternatively, number 0 1 can given, determining proportion doublets perform size adjustment. adjustSize Logical; whether adjust size doublets using ratio cluster's median library size. Alternatively, number 0 1 can given, determining proportion doublets perform size adjustment. propRandom proportion created doublets fully random (default 0.1); rest doublets created across clusters. Ignored `clusters` NULL. selMode cell pair selection mode inter-cluster doublet generation, either 'uniform' (number doublets combination), 'proportional' (proportion expected clusters' prevalences), 'sqrt' (roughly square root expected proportion). n.meta.cells number meta-cell per cluster create. given, additional doublets created cluster meta-cells. Ignored `clusters` missing. meta.triplets Logical; whether create triplets meta cells. Ignored `clusters` missing. trim.q vector two values 0 1","code":""},{"path":"https://plger.github.io/scDblFinder/reference/getArtificialDoublets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"getArtificialDoublets — getArtificialDoublets","text":"list two elements: `counts` (count matrix artificial doublets) `origins` clusters artificial doublets originated (NULL `clusters` given).","code":""},{"path":"https://plger.github.io/scDblFinder/reference/getArtificialDoublets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"getArtificialDoublets — getArtificialDoublets","text":"","code":"m <- t(sapply( seq(from=0, to=5, length.out=50),                FUN=function(x) rpois(30,x) ) ) doublets <- getArtificialDoublets(m, 30)"},{"path":"https://plger.github.io/scDblFinder/reference/getCellPairs.html","id":null,"dir":"Reference","previous_headings":"","what":"getCellPairs — getCellPairs","title":"getCellPairs — getCellPairs","text":"Given vector cluster labels, returns pairs cross-cluster cells","code":""},{"path":"https://plger.github.io/scDblFinder/reference/getCellPairs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getCellPairs — getCellPairs","text":"","code":"getCellPairs(   clusters,   n = 1000,   ls = NULL,   q = c(0.1, 0.9),   selMode = \"proportional\",   soft.min = 5 )"},{"path":"https://plger.github.io/scDblFinder/reference/getCellPairs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getCellPairs — getCellPairs","text":"clusters vector cluster labels cell, list containing metacells graph n number cell pairs obtain ls Optional library sizes q Library size quantiles include cells (ignored  `ls` NULL) selMode decide number pairs kind produce. Either 'proportional' (default, proportional abundance  underlying clusters), 'uniform' 'sqrt'. soft.min Minimum number pairs given type.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/getCellPairs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"getCellPairs — getCellPairs","text":"data.frame columns","code":""},{"path":"https://plger.github.io/scDblFinder/reference/getCellPairs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"getCellPairs — getCellPairs","text":"","code":"# create random labels x <- sample(head(LETTERS), 100, replace=TRUE) getCellPairs(x, n=6) #>    cell1 cell2 orig.clusters #> 1     31    94           A+B #> 2     22    17           A+C #> 3     36    59           B+C #> 4     21    13           A+D #> 5     38    85           B+D #> 6     11    85           C+D #> 7     57    52           A+E #> 8     66     8           B+E #> 9     59    81           C+E #> 10    82    28           D+E #> 11    22    89           A+F #> 12    38    30           B+F #> 13    17    53           C+F #> 14    13    69           D+F #> 15    90    32           E+F"},{"path":"https://plger.github.io/scDblFinder/reference/getExpectedDoublets.html","id":null,"dir":"Reference","previous_headings":"","what":"getExpectedDoublets — getExpectedDoublets","title":"getExpectedDoublets — getExpectedDoublets","text":"getExpectedDoublets","code":""},{"path":"https://plger.github.io/scDblFinder/reference/getExpectedDoublets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getExpectedDoublets — getExpectedDoublets","text":"","code":"getExpectedDoublets(x, dbr = NULL, only.heterotypic = TRUE)"},{"path":"https://plger.github.io/scDblFinder/reference/getExpectedDoublets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getExpectedDoublets — getExpectedDoublets","text":"x vector cluster labels cell dbr expected doublet rate. .heterotypic Logical; whether return expectations heterotypic doublets","code":""},{"path":"https://plger.github.io/scDblFinder/reference/getExpectedDoublets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"getExpectedDoublets — getExpectedDoublets","text":"expected number doublets combination clusters","code":""},{"path":"https://plger.github.io/scDblFinder/reference/getExpectedDoublets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"getExpectedDoublets — getExpectedDoublets","text":"","code":"# random cluster labels cl <- sample(head(LETTERS,4), size=2000, prob=c(.4,.2,.2,.2), replace=TRUE) getExpectedDoublets(cl) #>     A+B     A+C     B+C     A+D     B+D     C+D  #> 6.65532 6.19248 3.23592 6.33612 3.31098 3.08072"},{"path":"https://plger.github.io/scDblFinder/reference/getFragmentOverlaps.html","id":null,"dir":"Reference","previous_headings":"","what":"getFragmentOverlaps — getFragmentOverlaps","title":"getFragmentOverlaps — getFragmentOverlaps","text":"Count number overlapping fragments.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/getFragmentOverlaps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getFragmentOverlaps — getFragmentOverlaps","text":"","code":"getFragmentOverlaps(   x,   barcodes = NULL,   regionsToExclude = GRanges(c(\"M\", \"chrM\", \"MT\", \"X\", \"Y\", \"chrX\", \"chrY\"), IRanges(1L,     width = 10^8)),   minFrags = 500L,   uniqueFrags = TRUE,   maxFragSize = 1000L,   removeHighOverlapSites = TRUE,   fullInMemory = FALSE,   BPPARAM = NULL,   verbose = TRUE,   ret = c(\"stats\", \"loci\", \"coverages\") )"},{"path":"https://plger.github.io/scDblFinder/reference/getFragmentOverlaps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getFragmentOverlaps — getFragmentOverlaps","text":"x path fragments file, GRanges object containing fragments (`name` column containing barcode, optionally  `score` column containing count). barcodes Optional character vector cell barcodes consider regionsToExclude GRanges regions exclude. per original Amulet method, recommend excluding repeats, well sex  mitochondrial chromosomes. minFrags Minimum number fragments barcode  considered. `uniqueFrags=TRUE`, minimum number unique  fragments. Ignored `barcodes` given. uniqueFrags Logical; whether use unique fragments. maxFragSize Integer indicating maximum fragment size consider removeHighOverlapSites Logical; whether remove sites two reads unexpectedly many cells. fullInMemory Logical; whether process chromosomes together. speed process cost high memory  consumption (fragments loaded memory). anyway default mode `x` Tabix-indexed. BPPARAM `BiocParallel` parameter object multithreading. Note  multithreading increase memory usage. verbose Logical; whether print progress messages. ret return, either barcode 'stats' (default), 'loci', 'coverages'.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/getFragmentOverlaps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"getFragmentOverlaps — getFragmentOverlaps","text":"data.frame counts overlap statistics barcode.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/getFragmentOverlaps.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"getFragmentOverlaps — getFragmentOverlaps","text":"used normal (compressed) fragment files,  implementation relatively fast (except reading data)  large memory footprint since overlaps performed memory.  therefore recommended compress fragment files using bgzip index Tabix; case chromosome read processed  separately, leading considerably lower memory footprint.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/mockDoubletSCE.html","id":null,"dir":"Reference","previous_headings":"","what":"mockDoubletSCE — mockDoubletSCE","title":"mockDoubletSCE — mockDoubletSCE","text":"Creates mock random single-cell experiment object doublets","code":""},{"path":"https://plger.github.io/scDblFinder/reference/mockDoubletSCE.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"mockDoubletSCE — mockDoubletSCE","text":"","code":"mockDoubletSCE(   ncells = c(200, 300),   ngenes = 200,   mus = NULL,   dbl.rate = 0.1,   only.heterotypic = TRUE )"},{"path":"https://plger.github.io/scDblFinder/reference/mockDoubletSCE.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"mockDoubletSCE — mockDoubletSCE","text":"ncells positive integer vector indicating number cells per cluster (min 2 clusters) ngenes number genes simulate. Ignored `mus` given. mus list cluster averages. dbl.rate doublet rate .heterotypic Whether create heterotypic doublets","code":""},{"path":"https://plger.github.io/scDblFinder/reference/mockDoubletSCE.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"mockDoubletSCE — mockDoubletSCE","text":"SingleCellExperiment object, colData columns `type` indicating whether cell singlet doublet, `cluster` indicating cluster (cluster combination) simulated.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/mockDoubletSCE.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"mockDoubletSCE — mockDoubletSCE","text":"","code":"sce <- mockDoubletSCE()"},{"path":"https://plger.github.io/scDblFinder/reference/plotDoubletMap.html","id":null,"dir":"Reference","previous_headings":"","what":"plotDoubletMap — plotDoubletMap","title":"plotDoubletMap — plotDoubletMap","text":"Plots heatmap observed versus expected doublets. Requires `ComplexHeatmap` package.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/plotDoubletMap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plotDoubletMap — plotDoubletMap","text":"","code":"plotDoubletMap(   sce,   colorBy = \"enrichment\",   labelBy = \"observed\",   addSizes = TRUE,   col = NULL,   column_title = \"Clusters\",   row_title = \"Clusters\",   column_title_side = \"bottom\",   na_col = \"white\",   ... )"},{"path":"https://plger.github.io/scDblFinder/reference/plotDoubletMap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plotDoubletMap — plotDoubletMap","text":"sce SingleCellExperiment object `scDblFinder` run cluster-based approach. colorBy Determines color mapping. Either \"enrichment\" (log2-enrichment expectation) column `metadata(sce)$scDblFinder.stats` labelBy Determines cell labels. Either \"enrichment\" (log2-enrichment expectation) column  `metadata(sce)$scDblFinder.stats` addSizes Logical; whether add sizes clusters labels col colors scale use (passed `ComplexHeatmap::Heatmap`) column_title passed `ComplexHeatmap::Heatmap` row_title passed `ComplexHeatmap::Heatmap` column_title_side passed `ComplexHeatmap::Heatmap` na_col color NA cells ... passed `ComplexHeatmap::Heatmap`","code":""},{"path":"https://plger.github.io/scDblFinder/reference/plotDoubletMap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"plotDoubletMap — plotDoubletMap","text":"Heatmap object","code":""},{"path":"https://plger.github.io/scDblFinder/reference/plotThresholds.html","id":null,"dir":"Reference","previous_headings":"","what":"plotThresholds — plotThresholds","title":"plotThresholds — plotThresholds","text":"Plots scores used thresholding.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/plotThresholds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plotThresholds — plotThresholds","text":"","code":"plotThresholds(d, ths = (0:100)/100, dbr = NULL, dbr.sd = NULL, do.plot = TRUE)"},{"path":"https://plger.github.io/scDblFinder/reference/plotThresholds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plotThresholds — plotThresholds","text":"d data.frame cell properties, row representing cell, produced `scDblFinder(..., returnType=\"table\")`. ths vector thresholds 0 1 plot values. dbr expected (mean) doublet rate. dbr.sd standard deviation doublet rate, representing uncertainty estimate. .plot Logical; whether plot data (otherwise return underlying data.frame).","code":""},{"path":"https://plger.github.io/scDblFinder/reference/plotThresholds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"plotThresholds — plotThresholds","text":"ggplot, data.frame `.plot==FALSE`.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/propHomotypic.html","id":null,"dir":"Reference","previous_headings":"","what":"propHomotypic — propHomotypic","title":"propHomotypic — propHomotypic","text":"Computes proportion pairs expected made elements  cluster.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/propHomotypic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"propHomotypic — propHomotypic","text":"","code":"propHomotypic(clusters)"},{"path":"https://plger.github.io/scDblFinder/reference/propHomotypic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"propHomotypic — propHomotypic","text":"clusters vector cluster labels","code":""},{"path":"https://plger.github.io/scDblFinder/reference/propHomotypic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"propHomotypic — propHomotypic","text":"numeric value 0 1.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/propHomotypic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"propHomotypic — propHomotypic","text":"","code":"clusters <- sample(LETTERS[1:5], 100, replace=TRUE) propHomotypic(clusters) #> [1] 0.2034"},{"path":"https://plger.github.io/scDblFinder/reference/recoverDoublets.html","id":null,"dir":"Reference","previous_headings":"","what":"Recover intra-sample doublets — recoverDoublets","title":"Recover intra-sample doublets — recoverDoublets","text":"Recover intra-sample doublets neighbors known inter-sample doublets multiplexed experiment.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/recoverDoublets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recover intra-sample doublets — recoverDoublets","text":"","code":"recoverDoublets(x, ...)  # S4 method for ANY recoverDoublets(   x,   doublets,   samples,   k = 50,   transposed = FALSE,   subset.row = NULL,   BNPARAM = KmknnParam(),   BPPARAM = SerialParam() )  # S4 method for SummarizedExperiment recoverDoublets(x, ..., assay.type = \"logcounts\")  # S4 method for SingleCellExperiment recoverDoublets(x, ..., use.dimred = NULL)"},{"path":"https://plger.github.io/scDblFinder/reference/recoverDoublets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recover intra-sample doublets — recoverDoublets","text":"x log-expression matrix cells (including doublets) columns genes rows. transposed=TRUE, matrix low-dimensional coordinates row corresponds cell. Alternatively, SummarizedExperiment SingleCellExperiment containing  () log-expression matrix assays specified assay.type, (ii) matrix reduced dimensions reducedDims specified use.dimred. ... generic, additional arguments pass specific methods. SummarizedExperiment method, additional arguments pass method. SingleCellExperiment method, additional arguments pass SummarizedExperiment method. doublets logical, integer character vector specifying cells x known (inter-sample) doublets. samples numeric vector containing relative proportions cells sample, used determine many cells considered intra-sample doublets. k Integer scalar specifying number nearest neighbors use computing local doublet proportions. transposed Logical scalar indicating whether x transposed, .e., cells rows. subset.row logical, integer character vector specifying genes use neighbor search.  used transposed=FALSE. BNPARAM BiocNeighborParam object specifying algorithm use nearest neighbor search. BPPARAM BiocParallelParam object specifying parallelization use nearest neighbor search. assay.type string specifying assay values contain log-expression matrix. use.dimred string specifying whether existing values reducedDims(x) used.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/recoverDoublets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Recover intra-sample doublets — recoverDoublets","text":"DataFrame containing one row per cell following fields: proportion, numeric field containing proportion neighbors doublets. known, logical field indicating whether cell known inter-sample doublet. predicted, logical field indicating whether cell predicted intra-sample doublet. metadata contains intra, numeric scalar containing expected number intra-sample doublets.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/recoverDoublets.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Recover intra-sample doublets — recoverDoublets","text":"multiplexed single-cell experiments, can detect doublets libraries labels multiple samples. However, approach fails identify doublets consisting two cells label. cells may problematic still sufficiently abundant drive formation spurious clusters. function identifies intra-sample doublets based similarity expression profiles known inter-sample doublets. cell, compute proportion k neighbors known doublets. “unmarked” cells known doublets, top \\(X\\) largest proportions considered intra-sample doublets. use samples obtain reasonable estimate \\(X\\), see vignette details. larger value k provides stable estimates doublet proportion cell. However, comes cost assuming cell actually k neighboring cells state. example, doublet cluster fewer k members, doublet proportions “diluted” inclusion unmarked cells next-closest cluster.","code":""},{"path":[]},{"path":"https://plger.github.io/scDblFinder/reference/recoverDoublets.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Recover intra-sample doublets — recoverDoublets","text":"Aaron Lun","code":""},{"path":"https://plger.github.io/scDblFinder/reference/recoverDoublets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Recover intra-sample doublets — recoverDoublets","text":"","code":"# Mocking up an example. set.seed(100) ngenes <- 1000 mu1 <- 2^rnorm(ngenes, sd=2) mu2 <- 2^rnorm(ngenes, sd=2)  counts.1 <- matrix(rpois(ngenes*100, mu1), nrow=ngenes) # Pure type 1 counts.2 <- matrix(rpois(ngenes*100, mu2), nrow=ngenes) # Pure type 2 counts.m <- matrix(rpois(ngenes*20, mu1+mu2), nrow=ngenes) # Doublets (1 & 2) all.counts <- cbind(counts.1, counts.2, counts.m) lcounts <- scuttle::normalizeCounts(all.counts)  # Pretending that half of the doublets are known. Also pretending that  # the experiment involved two samples of equal size. known <- 200 + seq_len(10)  out <- recoverDoublets(lcounts, doublets=known, k=10, samples=c(1, 1)) out #> DataFrame with 220 rows and 3 columns #>     proportion     known predicted #>      <numeric> <logical> <logical> #> 1            0     FALSE     FALSE #> 2            0     FALSE     FALSE #> 3            0     FALSE     FALSE #> 4            0     FALSE     FALSE #> 5            0     FALSE     FALSE #> ...        ...       ...       ... #> 216        0.5     FALSE      TRUE #> 217        0.5     FALSE      TRUE #> 218        0.4     FALSE      TRUE #> 219        0.3     FALSE      TRUE #> 220        0.4     FALSE      TRUE"},{"path":"https://plger.github.io/scDblFinder/reference/scDblFinder.html","id":null,"dir":"Reference","previous_headings":"","what":"scDblFinder — scDblFinder","title":"scDblFinder — scDblFinder","text":"Identification heterotypic (neotypic) doublets single-cell RNAseq using cluster-based generation artificial doublets.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/scDblFinder.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"scDblFinder — scDblFinder","text":"","code":"scDblFinder(   sce,   clusters = NULL,   samples = NULL,   clustCor = NULL,   artificialDoublets = NULL,   knownDoublets = NULL,   knownUse = c(\"discard\", \"positive\"),   dbr = NULL,   dbr.sd = NULL,   nfeatures = 1352,   dims = 20,   k = NULL,   removeUnidentifiable = TRUE,   includePCs = 19,   propRandom = 0,   propMarkers = 0,   aggregateFeatures = FALSE,   returnType = c(\"sce\", \"table\", \"full\", \"counts\"),   score = c(\"xgb\", \"weighted\", \"ratio\"),   processing = \"default\",   metric = \"logloss\",   nrounds = 0.25,   max_depth = 4,   iter = 3,   trainingFeatures = NULL,   unident.th = NULL,   multiSampleMode = c(\"split\", \"singleModel\", \"singleModelSplitThres\", \"asOne\"),   threshold = TRUE,   verbose = is.null(samples),   BPPARAM = SerialParam(),   ... )"},{"path":"https://plger.github.io/scDblFinder/reference/scDblFinder.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"scDblFinder — scDblFinder","text":"sce SummarizedExperiment-class, SingleCellExperiment-class, array counts. clusters optional cluster assignments. used make doublets efficiently. clusters either vector labels cell, name colData column sce. Alternatively, `clusters=TRUE`, fast clustering performed. `clusters` single integer, determine many clusters create (using k-means clustering). `clusters` NULL FALSE, purely random artificial doublets generated. samples vector length cells (name column colData(x)), indicating sample cell belongs. , sample understood processed independently. omitted, doublets searched cells together. given, doublets searched independently sample, preferable represent different captures. samples multiplexed using cell hashes, want give different batches/wells (.e. independent captures, since doublets arise across ) rather biological samples. clustCor Include Spearman correlations cell type averages predictors. `clustCor` matrix cell type marker expressions (features rows cell types columns), subset present selected features correlated cell produce additional predictors (.e. one per cell type). Alternatively, `clustCor` positive integer, number inter-cluster markers selected used correlation (se `clustCor=Inf` use available genes). artificialDoublets approximate number artificial doublets create. NULL, maximum number cells 5*nbClusters^2 (minimum 1500). knownDoublets optional logical vector known doublets (e.g. cell barcodes), name colData column `sce` containing information. way used depends `knownUse` argument. knownUse way use known doublets, either 'discard' (discarded purpose training, counted positive  thresholding) 'positive' (used positive doublets training  - usually leads mild decrease accuracy due fact known  doublets typically include sizeable fraction homotypic doublets). Note `scDblFinder` ** enforce knownDoublets necessarily called doublets final classification, predicted  . dbr expected doublet rate. default assumed 1% per thousand cells captured (4% among 4000 thousand cells), appropriate 10x datasets. Corrections homeotypic doublets performed given rate. dbr.sd uncertainty range doublet rate, interpreted +/- around `dbr`. thresholding, deviation expected doublet rate calculated boundaries, considered null within boundaries. NULL, 40% `dbr`. Set `dbr.sd=0`  disable uncertainty around doublet rate, `dbr.sd=1` disable  expectation number doublets (thus letting thresholding  entirely driven misclassification artificial doublets). nfeatures number top features use. Alternatively,  character vectors feature names (e.g. highly-variable genes) use. dims number dimensions used. k Number nearest neighbors (KNN graph). one value given, doublet density calculated k (values highest k), information used classifier. omitted, reasonable set values used. removeUnidentifiable Logical; whether remove artificial doublets combination generally found unidentifiable. includePCs index principal components include predictors (e.g. `includePCs=1:2`), number top components use (e.g. `includePCs=10`, equivalent 1:10). propRandom proportion artificial doublets made random cells (opposed inter-cluster combinations). clusters FALSE NULL, ignored (set 1). propMarkers proportion features select based marker identification. aggregateFeatures Whether perform feature aggregation (recommended ATAC). Can also positive integer, case indicate number components use feature aggregation (TRUE, `dims` used.) returnType Either \"sce\" (default), \"table\" (return table cell attributes including artificial doublets), \"full\" (returns SCE object containing real artificial cells). score Score use final classification. processing Counts (real artificial) processing KNN. Either 'default' (normal scater-based normalization PCA), \"rawPCA\" (PCA without normalization), \"rawFeatures\" (normalization/dimensional reduction), \"normFeatures\" (uses normalized features, without PCA) custom function (least) arguments `e` (matrix counts) `dims` (desired number dimensions), returning named matrix cells rows components columns. metric Error metric optimize training (e.g. 'merror', 'logloss', 'auc', 'aucpr'). nrounds Maximum rounds boosting. NULL, determined cross-validation. number <=1, used best cross-validation round minus `nrounds` times standard deviation classification error. max_depth Maximum depths tree. iter positive integer indicating number scoring iterations (ignored `score` based classifiers). iteration, real cells called doublets excluding training, new scores calculated. Recommended values 1 2. trainingFeatures features use training (defaults optimal pre-selection based benchmark datasets). exclude features (rather list included), prefix \"-\". unident.th score threshold artificial doublets considered unidentifiable. multiSampleMode Either \"split\" (recommended heterogeneity across samples), \"singleModel\", \"singleModelSplitThres\", \"asOne\" (see details ). threshold Logical; whether threshold scores binary doublet calls verbose Logical; whether print messages thresholding plot. BPPARAM Used multithreading splitting samples (.e. `samples!=NULL`); otherwise passed eventual PCA K/SNN calculations. ... arguments passed getArtificialDoublets.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/scDblFinder.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"scDblFinder — scDblFinder","text":"sce object several additional colData columns, particular `scDblFinder.score` (final score used) `scDblFinder.class` (whether cell called 'doublet' 'singlet'). See vignette(\"scDblFinder\") details; alternative return values, see `returnType` argument.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/scDblFinder.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"scDblFinder — scDblFinder","text":"function generates artificial doublets real cells, evaluates prevalence neighborhood cells, uses along additional cell-level features classify doublets. approach complementary doublets identified via cell hashes SNPs multiplexed samples: latter can identify doublets formed cells type two samples, nearly undistinguishable real cells transcriptionally, identify doublets made cells sample. See vignette(\"scDblFinder\") details method. `clusters` `propRandom` argument determines whether artificial doublets generated clusters randomly. multiple samples/captures present, specified using samples argument. case, recommend use BPPARAM perform several steps parallel. Artificial doublets kNN networks computed separately; behavior depend `multiSampleMode` argument: split: whole process split sample.   default recommended mode, robust (e.g.   heterogeneity samples, also instance number cells),   practice seen major gains sharing information across   samples; singleModel: doublets generated per-sample basis,   classifier thresholding trained globally; singleModelSplitThres: doublets generated   per-sample basis, classifier trained globally, final   thresholding per-sample; asOne: doublet rate (given) calculated   weighted average sample-specific doublet rates, samples   otherwise run one sample. can get computationally   intensive, can lead biases batch effects. inter-sample doublets available, can provided `scDblFinder` knownDoublets argument improve identification doublets. exactly used depends `knownUse` argument: 'discard' (default), known doublets excluded training step, counted positives. 'positive', included treated positive doublets training step. Note known doublets can practice include lot homotypic doublets, second approach can often lead slight decrease accuracy detecting heterotypic doublets. Finally, types data, single-cell ATAC-seq, selecting number top features ineffective due high sparsity signal. contexts, rather _selecting_ features recommend use alternative approach _aggregating_ similar features (`aggregateFeatures=TRUE`), strongly improves accuracy. See vignette detail.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/scDblFinder.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"scDblFinder — scDblFinder","text":"","code":"library(SingleCellExperiment) sce <- mockDoubletSCE() sce <- scDblFinder(sce) #> Creating ~1500 artificial doublets... #> Dimensional reduction #> Evaluating kNN... #> Training model... #> iter=0, 20 cells excluded from training. #> iter=1, 15 cells excluded from training. #> iter=2, 15 cells excluded from training. #> Threshold found:0.763 #> 16 (3%) doublets called table(truth=sce$type, call=sce$scDblFinder.class) #>          call #> truth     singlet doublet #>   singlet     499       1 #>   doublet      14      15"},{"path":"https://plger.github.io/scDblFinder/reference/selFeatures.html","id":null,"dir":"Reference","previous_headings":"","what":"selFeatures — selFeatures","title":"selFeatures — selFeatures","text":"Selects features based cluster-wise expression marker detection, combination.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/selFeatures.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"selFeatures — selFeatures","text":"","code":"selFeatures(   sce,   clusters = NULL,   nfeatures = 1000,   propMarkers = 0,   FDR.max = 0.05 )"},{"path":"https://plger.github.io/scDblFinder/reference/selFeatures.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"selFeatures — selFeatures","text":"sce SummarizedExperiment-class, SingleCellExperiment-class 'counts' assay. clusters Optional cluster assignments. either vector labels cell. nfeatures number features select. propMarkers proportion features select markers (rather basis high expression). Ignored `clusters` given. FDR.max maximum marker binom FDR included selection. (see findMarkers).","code":""},{"path":"https://plger.github.io/scDblFinder/reference/selFeatures.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"selFeatures — selFeatures","text":"vector feature (.e. row) names.","code":""},{"path":"https://plger.github.io/scDblFinder/reference/selFeatures.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"selFeatures — selFeatures","text":"","code":"sce <- mockDoubletSCE() selFeatures(sce, clusters=sce$cluster, nfeatures=5) #> [1] \"gene80\"  \"gene149\" \"gene130\" \"gene186\" \"gene200\""}]
